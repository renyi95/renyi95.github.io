<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.1.1"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css"><script src="https://cdn.jsdelivr.net/npm/echarts@5.1.1/dist/echarts.min.js"></script><script class="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"obsidianstar.cn",root:"/",images:"/images",scheme:"Pisces",version:"8.3.0",exturl:!1,sidebar:{position:"left",display:"always",padding:18,offset:12},copycode:!0,bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"fadeInDown",post_body:"fadeInDown",coll_header:"fadeInLeft",sidebar:"fadeInUp"}},prism:!1,i18n:{placeholder:"搜索...",empty:"没有找到任何搜索结果：${query}",hits_time:"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）",hits:"找到 ${hits} 个搜索结果"},path:"/search.xml",localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!0}}</script><meta name="description" content="浏览器支持大量的事件，本章介绍其中一些主要的事件。 鼠标事件鼠标事件指与鼠标相关的事件，继承了MouseEvent接口。具体的事件主要有以下一些。  click：按下鼠标（通常是按下主按钮）时触发。 dblclick：在同一个元素上双击鼠标时触发。 mousedown：按下鼠标键时触发。 mouseup：释放按下的鼠标键时触发。 mousemove：当鼠标在一个节点内部移动时触发。当鼠标持续移动时"><meta property="og:type" content="article"><meta property="og:title" content="事件种类"><meta property="og:url" content="https://obsidianstar.cn/2021/01/14/dom/event-type/index.html"><meta property="og:site_name" content="博客"><meta property="og:description" content="浏览器支持大量的事件，本章介绍其中一些主要的事件。 鼠标事件鼠标事件指与鼠标相关的事件，继承了MouseEvent接口。具体的事件主要有以下一些。  click：按下鼠标（通常是按下主按钮）时触发。 dblclick：在同一个元素上双击鼠标时触发。 mousedown：按下鼠标键时触发。 mouseup：释放按下的鼠标键时触发。 mousemove：当鼠标在一个节点内部移动时触发。当鼠标持续移动时"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2021-01-13T16:00:00.000Z"><meta property="article:modified_time" content="2022-12-27T02:53:30.243Z"><meta property="article:author" content="任毅"><meta property="article:tag" content="dom"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://obsidianstar.cn/2021/01/14/dom/event-type/"><script data-pjax class="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>事件种类 | 博客</title><noscript><style>body{margin-top:2rem}.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header,.use-motion .sidebar{visibility:visible}.use-motion .footer,.use-motion .header,.use-motion .site-brand-container .toggle{opacity:initial}.use-motion .custom-logo-image,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line{transform:scaleX(1)}.search-pop-overlay,.sidebar-nav{display:none}.sidebar-panel{display:block}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><h1 class="site-title">博客</h1><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">297</span></a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">47</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">36</span></a></li><li class="menu-item menu-item-photos"><a href="/photos/" rel="section"><i class="fa fa-user fa-fw"></i>照片</a></li><li class="menu-item menu-item-book"><a href="/book/" rel="section"><i class="fa fa-calendar fa-fw"></i>工具书</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6"><span class="nav-number">1.</span> <span class="nav-text">鼠标事件</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MouseEvent-%E6%8E%A5%E5%8F%A3%E6%A6%82%E8%BF%B0"><span class="nav-number">2.</span> <span class="nav-text">MouseEvent 接口概述</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MouseEvent-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7"><span class="nav-number">3.</span> <span class="nav-text">MouseEvent 接口的实例属性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#MouseEvent-altKey%EF%BC%8CMouseEvent-ctrlKey%EF%BC%8CMouseEvent-metaKey%EF%BC%8CMouseEvent-shiftKey"><span class="nav-number">3.1.</span> <span class="nav-text">MouseEvent.altKey，MouseEvent.ctrlKey，MouseEvent.metaKey，MouseEvent.shiftKey</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MouseEvent-button%EF%BC%8CMouseEvent-buttons"><span class="nav-number">3.2.</span> <span class="nav-text">MouseEvent.button，MouseEvent.buttons</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MouseEvent-clientX%EF%BC%8CMouseEvent-clientY"><span class="nav-number">3.3.</span> <span class="nav-text">MouseEvent.clientX，MouseEvent.clientY</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MouseEvent-movementX%EF%BC%8CMouseEvent-movementY"><span class="nav-number">3.4.</span> <span class="nav-text">MouseEvent.movementX，MouseEvent.movementY</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MouseEvent-screenX%EF%BC%8CMouseEvent-screenY"><span class="nav-number">3.5.</span> <span class="nav-text">MouseEvent.screenX，MouseEvent.screenY</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MouseEvent-offsetX%EF%BC%8CMouseEvent-offsetY"><span class="nav-number">3.6.</span> <span class="nav-text">MouseEvent.offsetX，MouseEvent.offsetY</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MouseEvent-pageX%EF%BC%8CMouseEvent-pageY"><span class="nav-number">3.7.</span> <span class="nav-text">MouseEvent.pageX，MouseEvent.pageY</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MouseEvent-relatedTarget"><span class="nav-number">3.8.</span> <span class="nav-text">MouseEvent.relatedTarget</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MouseEvent-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="nav-number">4.</span> <span class="nav-text">MouseEvent 接口的实例方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#MouseEvent-getModifierState"><span class="nav-number">4.1.</span> <span class="nav-text">MouseEvent.getModifierState()</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#WheelEvent-%E6%8E%A5%E5%8F%A3"><span class="nav-number">5.</span> <span class="nav-text">WheelEvent 接口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">5.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7"><span class="nav-number">5.2.</span> <span class="nav-text">实例属性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6"><span class="nav-number">6.</span> <span class="nav-text">键盘事件</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#KeyboardEvent-%E6%8E%A5%E5%8F%A3"><span class="nav-number">7.</span> <span class="nav-text">KeyboardEvent 接口</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#KeyboardEvent-%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7"><span class="nav-number">8.</span> <span class="nav-text">KeyboardEvent 的实例属性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#KeyboardEvent-altKey%EF%BC%8CKeyboardEvent-metaKey-ctrlKey%EF%BC%8CKeyboardEvent-metaKey%EF%BC%8CKeyboardEvent-shiftKey"><span class="nav-number">8.1.</span> <span class="nav-text">KeyboardEvent.altKey，KeyboardEvent.metaKey.ctrlKey，KeyboardEvent.metaKey，KeyboardEvent.shiftKey</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#KeyboardEvent-code"><span class="nav-number">8.2.</span> <span class="nav-text">KeyboardEvent.code</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#KeyboardEvent-key"><span class="nav-number">8.3.</span> <span class="nav-text">KeyboardEvent.key</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#KeyboardEvent-location"><span class="nav-number">8.4.</span> <span class="nav-text">KeyboardEvent.location</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#KeyboardEvent-repeat"><span class="nav-number">8.5.</span> <span class="nav-text">KeyboardEvent.repeat</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#KeyboardEvent-%E7%9A%84%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="nav-number">9.</span> <span class="nav-text">KeyboardEvent 的实例方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#KeyboardEvent-getModifierState"><span class="nav-number">9.1.</span> <span class="nav-text">KeyboardEvent.getModifierState()</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E5%BA%A6%E4%BA%8B%E4%BB%B6"><span class="nav-number">10.</span> <span class="nav-text">进度事件</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ProgressEvent-%E6%8E%A5%E5%8F%A3"><span class="nav-number">11.</span> <span class="nav-text">ProgressEvent 接口</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8B%96%E6%8B%89%E4%BA%8B%E4%BB%B6"><span class="nav-number">12.</span> <span class="nav-text">拖拉事件</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DragEvent-%E6%8E%A5%E5%8F%A3"><span class="nav-number">13.</span> <span class="nav-text">DragEvent 接口</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DataTransfer-%E6%8E%A5%E5%8F%A3%E6%A6%82%E8%BF%B0"><span class="nav-number">14.</span> <span class="nav-text">DataTransfer 接口概述</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DataTransfer-%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7"><span class="nav-number">15.</span> <span class="nav-text">DataTransfer 的实例属性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#DataTransfer-dropEffect"><span class="nav-number">15.1.</span> <span class="nav-text">DataTransfer.dropEffect</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DataTransfer-effectAllowed"><span class="nav-number">15.2.</span> <span class="nav-text">DataTransfer.effectAllowed</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DataTransfer-files"><span class="nav-number">15.3.</span> <span class="nav-text">DataTransfer.files</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DataTransfer-types"><span class="nav-number">15.4.</span> <span class="nav-text">DataTransfer.types</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DataTransfer-items"><span class="nav-number">15.5.</span> <span class="nav-text">DataTransfer.items</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DataTransfer-%E7%9A%84%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="nav-number">16.</span> <span class="nav-text">DataTransfer 的实例方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#DataTransfer-setData"><span class="nav-number">16.1.</span> <span class="nav-text">DataTransfer.setData()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DataTransfer-getData"><span class="nav-number">16.2.</span> <span class="nav-text">DataTransfer.getData()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DataTransfer-clearData"><span class="nav-number">16.3.</span> <span class="nav-text">DataTransfer.clearData()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DataTransfer-setDragImage"><span class="nav-number">16.4.</span> <span class="nav-text">DataTransfer.setDragImage()</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A7%A6%E6%91%B8%E6%93%8D%E4%BD%9C%E6%A6%82%E8%BF%B0"><span class="nav-number">17.</span> <span class="nav-text">触摸操作概述</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Touch-%E6%8E%A5%E5%8F%A3"><span class="nav-number">18.</span> <span class="nav-text">Touch 接口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Touch-%E6%8E%A5%E5%8F%A3%E6%A6%82%E8%BF%B0"><span class="nav-number">18.1.</span> <span class="nav-text">Touch 接口概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Touch-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7"><span class="nav-number">18.2.</span> <span class="nav-text">Touch 接口的实例属性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#TouchList-%E6%8E%A5%E5%8F%A3"><span class="nav-number">19.</span> <span class="nav-text">TouchList 接口</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#TouchEvent-%E6%8E%A5%E5%8F%A3"><span class="nav-number">20.</span> <span class="nav-text">TouchEvent 接口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="nav-number">20.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7-1"><span class="nav-number">20.2.</span> <span class="nav-text">实例属性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="nav-number">21.</span> <span class="nav-text">触摸事件的种类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A1%A8%E5%8D%95%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="nav-number">22.</span> <span class="nav-text">表单事件的种类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#input-%E4%BA%8B%E4%BB%B6"><span class="nav-number">22.1.</span> <span class="nav-text">input 事件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#select-%E4%BA%8B%E4%BB%B6"><span class="nav-number">22.2.</span> <span class="nav-text">select 事件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Change-%E4%BA%8B%E4%BB%B6"><span class="nav-number">22.3.</span> <span class="nav-text">Change 事件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#invalid-%E4%BA%8B%E4%BB%B6"><span class="nav-number">22.4.</span> <span class="nav-text">invalid 事件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#reset-%E4%BA%8B%E4%BB%B6%EF%BC%8Csubmit-%E4%BA%8B%E4%BB%B6"><span class="nav-number">22.5.</span> <span class="nav-text">reset 事件，submit 事件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B5%84%E6%BA%90%E4%BA%8B%E4%BB%B6"><span class="nav-number">23.</span> <span class="nav-text">资源事件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#beforeunload-%E4%BA%8B%E4%BB%B6"><span class="nav-number">23.1.</span> <span class="nav-text">beforeunload 事件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#unload-%E4%BA%8B%E4%BB%B6"><span class="nav-number">23.2.</span> <span class="nav-text">unload 事件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#load-%E4%BA%8B%E4%BB%B6"><span class="nav-number">23.3.</span> <span class="nav-text">load 事件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#session-%E5%8E%86%E5%8F%B2%E4%BA%8B%E4%BB%B6"><span class="nav-number">24.</span> <span class="nav-text">session 历史事件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#pageshow-%E4%BA%8B%E4%BB%B6%EF%BC%8Cpagehide-%E4%BA%8B%E4%BB%B6"><span class="nav-number">24.1.</span> <span class="nav-text">pageshow 事件，pagehide 事件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#popstate-%E4%BA%8B%E4%BB%B6"><span class="nav-number">24.2.</span> <span class="nav-text">popstate 事件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#hashchange-%E4%BA%8B%E4%BB%B6"><span class="nav-number">24.3.</span> <span class="nav-text">hashchange 事件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BD%91%E9%A1%B5%E7%8A%B6%E6%80%81%E4%BA%8B%E4%BB%B6"><span class="nav-number">25.</span> <span class="nav-text">网页状态事件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#DOMContentLoaded-%E4%BA%8B%E4%BB%B6"><span class="nav-number">25.1.</span> <span class="nav-text">DOMContentLoaded 事件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#readystatechange-%E4%BA%8B%E4%BB%B6"><span class="nav-number">25.2.</span> <span class="nav-text">readystatechange 事件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AA%97%E5%8F%A3%E4%BA%8B%E4%BB%B6"><span class="nav-number">26.</span> <span class="nav-text">窗口事件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#scroll-%E4%BA%8B%E4%BB%B6"><span class="nav-number">26.1.</span> <span class="nav-text">scroll 事件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#resize-%E4%BA%8B%E4%BB%B6"><span class="nav-number">26.2.</span> <span class="nav-text">resize 事件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fullscreenchange-%E4%BA%8B%E4%BB%B6%EF%BC%8Cfullscreenerror-%E4%BA%8B%E4%BB%B6"><span class="nav-number">26.3.</span> <span class="nav-text">fullscreenchange 事件，fullscreenerror 事件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%AA%E8%B4%B4%E6%9D%BF%E4%BA%8B%E4%BB%B6"><span class="nav-number">27.</span> <span class="nav-text">剪贴板事件</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%84%A6%E7%82%B9%E4%BA%8B%E4%BB%B6"><span class="nav-number">28.</span> <span class="nav-text">焦点事件</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="任毅" src="/images/avatar.jpg"><p class="site-author-name" itemprop="name">任毅</p><div class="site-description" itemprop="description">平平无奇前端人，兢兢业业打工人</div></div><div class="site-state-wrap site-overview-item animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">297</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">36</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">47</span> <span class="site-state-item-name">标签</span></a></div></nav></div></div></div><div class="back-to-top animated" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div class="sidebar-dimmer"></div></header><div class="reading-progress-bar"></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://obsidianstar.cn/2021/01/14/dom/event-type/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="任毅"><meta itemprop="description" content="平平无奇前端人，兢兢业业打工人"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">事件种类</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-01-14 00:00:00" itemprop="dateCreated datePublished" datetime="2021-01-14T00:00:00+08:00">2021-01-14</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-12-27 10:53:30" itemprop="dateModified" datetime="2022-12-27T10:53:30+08:00">2022-12-27</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/dom/" itemprop="url" rel="index"><span itemprop="name">dom</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>浏览器支持大量的事件，本章介绍其中一些主要的事件。</p><h1 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h1><p>鼠标事件指与鼠标相关的事件，继承了<code>MouseEvent</code>接口。具体的事件主要有以下一些。</p><ul><li><code>click</code>：按下鼠标（通常是按下主按钮）时触发。</li><li><code>dblclick</code>：在同一个元素上双击鼠标时触发。</li><li><code>mousedown</code>：按下鼠标键时触发。</li><li><code>mouseup</code>：释放按下的鼠标键时触发。</li><li><code>mousemove</code>：当鼠标在一个节点内部移动时触发。当鼠标持续移动时，该事件会连续触发。为了避免性能问题，建议对该事件的监听函数做一些限定，比如限定一段时间内只能运行一次。</li><li><code>mouseenter</code>：鼠标进入一个节点时触发，进入子节点不会触发这个事件（详见后文）。</li><li><code>mouseover</code>：鼠标进入一个节点时触发，进入子节点会再一次触发这个事件（详见后文）。</li><li><code>mouseout</code>：鼠标离开一个节点时触发，离开父节点也会触发这个事件（详见后文）。</li><li><code>mouseleave</code>：鼠标离开一个节点时触发，离开父节点不会触发这个事件（详见后文）。</li><li><code>contextmenu</code>：按下鼠标右键时（上下文菜单出现前）触发，或者按下“上下文菜单键”时触发。</li><li><code>wheel</code>：滚动鼠标的滚轮时触发，该事件继承的是<code>WheelEvent</code>接口。</li></ul><p><code>click</code>事件指的是，用户在同一个位置先完成<code>mousedown</code>动作，再完成<code>mouseup</code>动作。因此，触发顺序是，<code>mousedown</code>首先触发，<code>mouseup</code>接着触发，<code>click</code>最后触发。</p><p><code>dblclick</code>事件则会在<code>mousedown</code>、<code>mouseup</code>、<code>click</code>之后触发。</p><p><code>mouseover</code>事件和<code>mouseenter</code>事件，都是鼠标进入一个节点时触发。两者的区别是，<code>mouseenter</code>事件只触发一次，而只要鼠标在节点内部移动，<code>mouseover</code>事件会在子节点上触发多次。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* HTML 代码如下</span></span><br><span class="line"><span class="comment"> &lt;ul&gt;</span></span><br><span class="line"><span class="comment">   &lt;li&gt;item 1&lt;/li&gt;</span></span><br><span class="line"><span class="comment">   &lt;li&gt;item 2&lt;/li&gt;</span></span><br><span class="line"><span class="comment">  &lt;li&gt;item 3&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">&quot;ul&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进入 ul 节点以后，mouseenter 事件只会触发一次</span></span><br><span class="line"><span class="comment">// 以后只要鼠标在节点内移动，都不会再触发这个事件</span></span><br><span class="line"><span class="comment">// event.target 是 ul 节点</span></span><br><span class="line">ul.addEventListener(</span><br><span class="line">  <span class="string">&quot;mouseenter&quot;</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    event.target.style.color = <span class="string">&quot;purple&quot;</span>;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      event.target.style.color = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;, <span class="number">500</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进入 ul 节点以后，只要在子节点上移动，mouseover 事件会触发多次</span></span><br><span class="line"><span class="comment">// event.target 是 li 节点</span></span><br><span class="line">ul.addEventListener(</span><br><span class="line">  <span class="string">&quot;mouseover&quot;</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    event.target.style.color = <span class="string">&quot;orange&quot;</span>;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      event.target.style.color = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;, <span class="number">500</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上面代码中，在父节点内部进入子节点，不会触发<code>mouseenter</code>事件，但是会触发<code>mouseover</code>事件。</p><p><code>mouseout</code>事件和<code>mouseleave</code>事件，都是鼠标离开一个节点时触发。两者的区别是，在父元素内部离开一个子元素时，<code>mouseleave</code>事件不会触发，而<code>mouseout</code>事件会触发。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* HTML 代码如下</span></span><br><span class="line"><span class="comment"> &lt;ul&gt;</span></span><br><span class="line"><span class="comment">   &lt;li&gt;item 1&lt;/li&gt;</span></span><br><span class="line"><span class="comment">   &lt;li&gt;item 2&lt;/li&gt;</span></span><br><span class="line"><span class="comment">  &lt;li&gt;item 3&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">&quot;ul&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先进入 ul 节点，然后在节点内部移动，不会触发 mouseleave 事件</span></span><br><span class="line"><span class="comment">// 只有离开 ul 节点时，触发一次 mouseleave</span></span><br><span class="line"><span class="comment">// event.target 是 ul 节点</span></span><br><span class="line">ul.addEventListener(</span><br><span class="line">  <span class="string">&quot;mouseleave&quot;</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    event.target.style.color = <span class="string">&quot;purple&quot;</span>;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      event.target.style.color = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;, <span class="number">500</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先进入 ul 节点，然后在节点内部移动，mouseout 事件会触发多次</span></span><br><span class="line"><span class="comment">// event.target 是 li 节点</span></span><br><span class="line">ul.addEventListener(</span><br><span class="line">  <span class="string">&quot;mouseout&quot;</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    event.target.style.color = <span class="string">&quot;orange&quot;</span>;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      event.target.style.color = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;, <span class="number">500</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上面代码中，在父节点内部离开子节点，不会触发<code>mouseleave</code>事件，但是会触发<code>mouseout</code>事件。</p><h1 id="MouseEvent-接口概述"><a href="#MouseEvent-接口概述" class="headerlink" title="MouseEvent 接口概述"></a>MouseEvent 接口概述</h1><p><code>MouseEvent</code>接口代表了鼠标相关的事件，单击（click）、双击（dblclick）、松开鼠标键（mouseup）、按下鼠标键（mousedown）等动作，所产生的事件对象都是<code>MouseEvent</code>实例。此外，滚轮事件和拖拉事件也是<code>MouseEvent</code>实例。</p><p><code>MouseEvent</code>接口继承了<code>Event</code>接口，所以拥有<code>Event</code>的所有属性和方法。它还有自己的属性和方法。</p><p>浏览器原生提供一个<code>MouseEvent</code>构造函数，用于新建一个<code>MouseEvent</code>实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> MouseEvent(type, options);</span><br></pre></td></tr></table></figure><p><code>MouseEvent</code>构造函数接受两个参数。第一个参数是字符串，表示事件名称；第二个参数是一个事件配置对象，该参数可选。除了<code>Event</code>接口的实例配置属性，该对象可以配置以下属性，所有属性都是可选的。</p><ul><li><code>screenX</code>：数值，鼠标相对于屏幕的水平位置（单位像素），默认值为 0，设置该属性不会移动鼠标。</li><li><code>screenY</code>：数值，鼠标相对于屏幕的垂直位置（单位像素），其他与<code>screenX</code>相同。</li><li><code>clientX</code>：数值，鼠标相对于程序窗口的水平位置（单位像素），默认值为 0，设置该属性不会移动鼠标。</li><li><code>clientY</code>：数值，鼠标相对于程序窗口的垂直位置（单位像素），其他与<code>clientX</code>相同。</li><li><code>ctrlKey</code>：布尔值，是否同时按下了 Ctrl 键，默认值为<code>false</code>。</li><li><code>shiftKey</code>：布尔值，是否同时按下了 Shift 键，默认值为<code>false</code>。</li><li><code>altKey</code>：布尔值，是否同时按下 Alt 键，默认值为<code>false</code>。</li><li><code>metaKey</code>：布尔值，是否同时按下 Meta 键，默认值为<code>false</code>。</li><li><code>button</code>：数值，表示按下了哪一个鼠标按键，默认值为<code>0</code>，表示按下主键（通常是鼠标的左键）或者当前事件没有定义这个属性；<code>1</code>表示按下辅助键（通常是鼠标的中间键），<code>2</code>表示按下次要键（通常是鼠标的右键）。</li><li><code>buttons</code>：数值，表示按下了鼠标的哪些键，是一个三个比特位的二进制值，默认为<code>0</code>（没有按下任何键）。<code>1</code>（二进制<code>001</code>）表示按下主键（通常是左键），<code>2</code>（二进制<code>010</code>）表示按下次要键（通常是右键），<code>4</code>（二进制<code>100</code>）表示按下辅助键（通常是中间键）。因此，如果返回<code>3</code>（二进制<code>011</code>）就表示同时按下了左键和右键。</li><li><code>relatedTarget</code>：节点对象，表示事件的相关节点，默认为<code>null</code>。<code>mouseenter</code>和<code>mouseover</code>事件时，表示鼠标刚刚离开的那个元素节点；<code>mouseout</code>和<code>mouseleave</code>事件时，表示鼠标正在进入的那个元素节点。</li></ul><p>下面是一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">simulateClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> event = <span class="keyword">new</span> MouseEvent(<span class="string">&quot;click&quot;</span>, &#123;</span><br><span class="line">    bubbles: <span class="literal">true</span>,</span><br><span class="line">    cancelable: <span class="literal">true</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">var</span> cb = <span class="built_in">document</span>.getElementById(<span class="string">&quot;checkbox&quot;</span>);</span><br><span class="line">  cb.dispatchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码生成一个鼠标点击事件，并触发该事件。</p><h1 id="MouseEvent-接口的实例属性"><a href="#MouseEvent-接口的实例属性" class="headerlink" title="MouseEvent 接口的实例属性"></a>MouseEvent 接口的实例属性</h1><h2 id="MouseEvent-altKey，MouseEvent-ctrlKey，MouseEvent-metaKey，MouseEvent-shiftKey"><a href="#MouseEvent-altKey，MouseEvent-ctrlKey，MouseEvent-metaKey，MouseEvent-shiftKey" class="headerlink" title="MouseEvent.altKey，MouseEvent.ctrlKey，MouseEvent.metaKey，MouseEvent.shiftKey"></a>MouseEvent.altKey，MouseEvent.ctrlKey，MouseEvent.metaKey，MouseEvent.shiftKey</h2><p><code>MouseEvent.altKey</code>、<code>MouseEvent.ctrlKey</code>、<code>MouseEvent.metaKey</code>、<code>MouseEvent.shiftKey</code>这四个属性都返回一个布尔值，表示事件发生时，是否按下对应的键。它们都是只读属性。</p><ul><li><code>altKey</code>属性：Alt 键</li><li><code>ctrlKey</code>属性：Ctrl 键</li><li><code>metaKey</code>属性：Meta 键（Mac 键盘是一个四瓣的小花，Windows 键盘是 Windows 键）</li><li><code>shiftKey</code>属性：Shift 键</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;body onclick=&quot;showKey(event)&quot;&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showKey</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;ALT key pressed: &quot;</span> + e.altKey);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;CTRL key pressed: &quot;</span> + e.ctrlKey);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;META key pressed: &quot;</span> + e.metaKey);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;SHIFT key pressed: &quot;</span> + e.shiftKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，点击网页会输出是否同时按下对应的键。</p><h2 id="MouseEvent-button，MouseEvent-buttons"><a href="#MouseEvent-button，MouseEvent-buttons" class="headerlink" title="MouseEvent.button，MouseEvent.buttons"></a>MouseEvent.button，MouseEvent.buttons</h2><p><code>MouseEvent.button</code>属性返回一个数值，表示事件发生时按下了鼠标的哪个键。该属性只读。</p><ul><li>0：按下主键（通常是左键），或者该事件没有初始化这个属性（比如<code>mousemove</code>事件）。</li><li>1：按下辅助键（通常是中键或者滚轮键）。</li><li>2：按下次键（通常是右键）。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为</span></span><br><span class="line"><span class="comment">// &lt;button onmouseup=&quot;whichButton(event)&quot;&gt;点击&lt;/button&gt;</span></span><br><span class="line"><span class="keyword">var</span> whichButton = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (e.button) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;Left button clicked.&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;Middle button clicked.&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;Right button clicked.&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;Unexpected code: &quot;</span> + e.button);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>MouseEvent.buttons</code>属性返回一个三个比特位的值，表示同时按下了哪些键。它用来处理同时按下多个鼠标键的情况。该属性只读。</p><ul><li>1：二进制为<code>001</code>（十进制的 1），表示按下左键。</li><li>2：二进制为<code>010</code>（十进制的 2），表示按下右键。</li><li>4：二进制为<code>100</code>（十进制的 4），表示按下中键或滚轮键。</li></ul><p>同时按下多个键的时候，每个按下的键对应的比特位都会有值。比如，同时按下左键和右键，会返回 3（二进制为 011）。</p><h2 id="MouseEvent-clientX，MouseEvent-clientY"><a href="#MouseEvent-clientX，MouseEvent-clientY" class="headerlink" title="MouseEvent.clientX，MouseEvent.clientY"></a>MouseEvent.clientX，MouseEvent.clientY</h2><p><code>MouseEvent.clientX</code>属性返回鼠标位置相对于浏览器窗口左上角的水平坐标（单位像素），<code>MouseEvent.clientY</code>属性返回垂直坐标。这两个属性都是只读属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为</span></span><br><span class="line"><span class="comment">// &lt;body onmousedown=&quot;showCoords(event)&quot;&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showCoords</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(</span><br><span class="line">    <span class="string">&quot;clientX value: &quot;</span> +</span><br><span class="line">      evt.clientX +</span><br><span class="line">      <span class="string">&quot;\n&quot;</span> +</span><br><span class="line">      <span class="string">&quot;clientY value: &quot;</span> +</span><br><span class="line">      evt.clientY +</span><br><span class="line">      <span class="string">&quot;\n&quot;</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个属性还分别有一个别名<code>MouseEvent.x</code>和<code>MouseEvent.y</code>。</p><h2 id="MouseEvent-movementX，MouseEvent-movementY"><a href="#MouseEvent-movementX，MouseEvent-movementY" class="headerlink" title="MouseEvent.movementX，MouseEvent.movementY"></a>MouseEvent.movementX，MouseEvent.movementY</h2><p><code>MouseEvent.movementX</code>属性返回当前位置与上一个<code>mousemove</code>事件之间的水平距离（单位像素）。数值上，它等于下面的计算公式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">currentEvent.movementX = currentEvent.screenX - previousEvent.screenX;</span><br></pre></td></tr></table></figure><p><code>MouseEvent.movementY</code>属性返回当前位置与上一个<code>mousemove</code>事件之间的垂直距离（单位像素）。数值上，它等于下面的计算公式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">currentEvent.movementY = currentEvent.screenY - previousEvent.screenY。</span><br></pre></td></tr></table></figure><p>这两个属性都是只读属性。</p><h2 id="MouseEvent-screenX，MouseEvent-screenY"><a href="#MouseEvent-screenX，MouseEvent-screenY" class="headerlink" title="MouseEvent.screenX，MouseEvent.screenY"></a>MouseEvent.screenX，MouseEvent.screenY</h2><p><code>MouseEvent.screenX</code>属性返回鼠标位置相对于屏幕左上角的水平坐标（单位像素），<code>MouseEvent.screenY</code>属性返回垂直坐标。这两个属性都是只读属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;body onmousedown=&quot;showCoords(event)&quot;&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showCoords</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(</span><br><span class="line">    <span class="string">&#x27;screenX value: &#x27;</span> + evt.screenX + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">    <span class="string">&#x27;screenY value: &#x27;</span> + evt.screenY + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="MouseEvent-offsetX，MouseEvent-offsetY"><a href="#MouseEvent-offsetX，MouseEvent-offsetY" class="headerlink" title="MouseEvent.offsetX，MouseEvent.offsetY"></a>MouseEvent.offsetX，MouseEvent.offsetY</h2><p><code>MouseEvent.offsetX</code>属性返回鼠标位置与目标节点左侧的<code>padding</code>边缘的水平距离（单位像素），<code>MouseEvent.offsetY</code>属性返回与目标节点上方的<code>padding</code>边缘的垂直距离。这两个属性都是只读属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* HTML 代码如下</span></span><br><span class="line"><span class="comment">  &lt;style&gt;</span></span><br><span class="line"><span class="comment">    p &#123;</span></span><br><span class="line"><span class="comment">      width: 100px;</span></span><br><span class="line"><span class="comment">      height: 100px;</span></span><br><span class="line"><span class="comment">      padding: 100px;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  &lt;/style&gt;</span></span><br><span class="line"><span class="comment">  &lt;p&gt;Hello&lt;/p&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.querySelector(<span class="string">&quot;p&quot;</span>);</span><br><span class="line">p.addEventListener(</span><br><span class="line">  <span class="string">&quot;click&quot;</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.offsetX);</span><br><span class="line">    <span class="built_in">console</span>.log(e.offsetY);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上面代码中，鼠标如果在<code>p</code>元素的中心位置点击，会返回<code>150 150</code>。因此中心位置距离左侧和上方的<code>padding</code>边缘，等于<code>padding</code>的宽度（100 像素）加上元素内容区域一半的宽度（50 像素）。</p><h2 id="MouseEvent-pageX，MouseEvent-pageY"><a href="#MouseEvent-pageX，MouseEvent-pageY" class="headerlink" title="MouseEvent.pageX，MouseEvent.pageY"></a>MouseEvent.pageX，MouseEvent.pageY</h2><p><code>MouseEvent.pageX</code>属性返回鼠标位置与文档左侧边缘的距离（单位像素），<code>MouseEvent.pageY</code>属性返回与文档上侧边缘的距离（单位像素）。它们的返回值都包括文档不可见的部分。这两个属性都是只读。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* HTML 代码如下</span></span><br><span class="line"><span class="comment">  &lt;style&gt;</span></span><br><span class="line"><span class="comment">    body &#123;</span></span><br><span class="line"><span class="comment">      height: 2000px;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  &lt;/style&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(</span><br><span class="line">  <span class="string">&quot;click&quot;</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.pageX);</span><br><span class="line">    <span class="built_in">console</span>.log(e.pageY);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上面代码中，页面高度为 2000 像素，会产生垂直滚动条。滚动到页面底部，点击鼠标输出的<code>pageY</code>值会接近 2000。</p><h2 id="MouseEvent-relatedTarget"><a href="#MouseEvent-relatedTarget" class="headerlink" title="MouseEvent.relatedTarget"></a>MouseEvent.relatedTarget</h2><p><code>MouseEvent.relatedTarget</code>属性返回事件的相关节点。对于那些没有相关节点的事件，该属性返回<code>null</code>。该属性只读。</p><p>下表列出不同事件的<code>target</code>属性值和<code>relatedTarget</code>属性值义。</p><table><thead><tr><th>事件名称</th><th>target 属性</th><th>relatedTarget 属性</th></tr></thead><tbody><tr><td>focusin</td><td>接受焦点的节点</td><td>丧失焦点的节点</td></tr><tr><td>focusout</td><td>丧失焦点的节点</td><td>接受焦点的节点</td></tr><tr><td>mouseenter</td><td>将要进入的节点</td><td>将要离开的节点</td></tr><tr><td>mouseleave</td><td>将要离开的节点</td><td>将要进入的节点</td></tr><tr><td>mouseout</td><td>将要离开的节点</td><td>将要进入的节点</td></tr><tr><td>mouseover</td><td>将要进入的节点</td><td>将要离开的节点</td></tr><tr><td>dragenter</td><td>将要进入的节点</td><td>将要离开的节点</td></tr><tr><td>dragexit</td><td>将要离开的节点</td><td>将要进入的节点</td></tr></tbody></table><p>下面是一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  HTML 代码如下</span></span><br><span class="line"><span class="comment">  &lt;div id=&quot;outer&quot; style=&quot;height:50px;width:50px;border-width:1px solid black;&quot;&gt;</span></span><br><span class="line"><span class="comment">    &lt;div id=&quot;inner&quot; style=&quot;height:25px;width:25px;border:1px solid black;&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="comment">  &lt;/div&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> inner = <span class="built_in">document</span>.getElementById(<span class="string">&quot;inner&quot;</span>);</span><br><span class="line">inner.addEventListener(</span><br><span class="line">  <span class="string">&quot;mouseover&quot;</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;进入&quot;</span> + event.target.id + <span class="string">&quot; 离开&quot;</span> + event.relatedTarget.id);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br><span class="line">inner.addEventListener(<span class="string">&quot;mouseenter&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;进入&quot;</span> + event.target.id + <span class="string">&quot; 离开&quot;</span> + event.relatedTarget.id);</span><br><span class="line">&#125;);</span><br><span class="line">inner.addEventListener(<span class="string">&quot;mouseout&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;离开&quot;</span> + event.target.id + <span class="string">&quot; 进入&quot;</span> + event.relatedTarget.id);</span><br><span class="line">&#125;);</span><br><span class="line">inner.addEventListener(<span class="string">&quot;mouseleave&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;离开&quot;</span> + event.target.id + <span class="string">&quot; 进入&quot;</span> + event.relatedTarget.id);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 鼠标从 outer 进入inner，输出</span></span><br><span class="line"><span class="comment">// 进入inner 离开outer</span></span><br><span class="line"><span class="comment">// 进入inner 离开outer</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 鼠标从 inner进入 outer，输出</span></span><br><span class="line"><span class="comment">// 离开inner 进入outer</span></span><br><span class="line"><span class="comment">// 离开inner 进入outer</span></span><br></pre></td></tr></table></figure><h1 id="MouseEvent-接口的实例方法"><a href="#MouseEvent-接口的实例方法" class="headerlink" title="MouseEvent 接口的实例方法"></a>MouseEvent 接口的实例方法</h1><h2 id="MouseEvent-getModifierState"><a href="#MouseEvent-getModifierState" class="headerlink" title="MouseEvent.getModifierState()"></a>MouseEvent.getModifierState()</h2><p><code>MouseEvent.getModifierState</code>方法返回一个布尔值，表示有没有按下特定的功能键。它的参数是一个表示<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/getModifierState#Modifier_keys_on_Gecko">功能键</a>的字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(</span><br><span class="line">  <span class="string">&quot;click&quot;</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.getModifierState(<span class="string">&quot;CapsLock&quot;</span>));</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上面的代码可以了解用户是否按下了大写键。</p><h1 id="WheelEvent-接口"><a href="#WheelEvent-接口" class="headerlink" title="WheelEvent 接口"></a>WheelEvent 接口</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>WheelEvent 接口继承了 MouseEvent 实例，代表鼠标滚轮事件的实例对象。目前，鼠标滚轮相关的事件只有一个<code>wheel</code>事件，用户滚动鼠标的滚轮，就生成这个事件的实例。</p><p>浏览器原生提供<code>WheelEvent()</code>构造函数，用来生成<code>WheelEvent</code>实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wheelEvent = <span class="keyword">new</span> WheelEvent(type, options);</span><br></pre></td></tr></table></figure><p><code>WheelEvent()</code>构造函数可以接受两个参数，第一个是字符串，表示事件类型，对于滚轮事件来说，这个值目前只能是<code>wheel</code>。第二个参数是事件的配置对象。该对象的属性除了<code>Event</code>、<code>UIEvent</code>的配置属性以外，还可以接受以下几个属性，所有属性都是可选的。</p><ul><li><code>deltaX</code>：数值，表示滚轮的水平滚动量，默认值是 0.0。</li><li><code>deltaY</code>：数值，表示滚轮的垂直滚动量，默认值是 0.0。</li><li><code>deltaZ</code>：数值，表示滚轮的 Z 轴滚动量，默认值是 0.0。</li><li><code>deltaMode</code>：数值，表示相关的滚动事件的单位，适用于上面三个属性。<code>0</code>表示滚动单位为像素，<code>1</code>表示单位为行，<code>2</code>表示单位为页，默认为<code>0</code>。</li></ul><h2 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h2><p><code>WheelEvent</code>事件实例除了具有<code>Event</code>和<code>MouseEvent</code>的实例属性和实例方法，还有一些自己的实例属性，但是没有自己的实例方法。</p><p>下面的属性都是只读属性。</p><ul><li><code>WheelEvent.deltaX</code>：数值，表示滚轮的水平滚动量。</li><li><code>WheelEvent.deltaY</code>：数值，表示滚轮的垂直滚动量。</li><li><code>WheelEvent.deltaZ</code>：数值，表示滚轮的 Z 轴滚动量。</li><li><code>WheelEvent.deltaMode</code>：数值，表示上面三个属性的单位，<code>0</code>是像素，<code>1</code>是行，<code>2</code>是页。</li></ul><h1 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h1><p>键盘事件由用户击打键盘触发，主要有<code>keydown</code>、<code>keypress</code>、<code>keyup</code>三个事件，它们都继承了<code>KeyboardEvent</code>接口。</p><ul><li><code>keydown</code>：按下键盘时触发。</li><li><code>keypress</code>：按下有值的键时触发，即按下 Ctrl、Alt、Shift、Meta 这样无值的键，这个事件不会触发。对于有值的键，按下时先触发<code>keydown</code>事件，再触发这个事件。</li><li><code>keyup</code>：松开键盘时触发该事件。</li></ul><p>如果用户一直按键不松开，就会连续触发键盘事件，触发的顺序如下。</p><ol><li>keydown</li><li>keypress</li><li>keydown</li><li>keypress</li><li>…（重复以上过程）</li><li>keyup</li></ol><h1 id="KeyboardEvent-接口"><a href="#KeyboardEvent-接口" class="headerlink" title="KeyboardEvent 接口"></a>KeyboardEvent 接口</h1><p><code>KeyboardEvent</code>接口用来描述用户与键盘的互动。这个接口继承了<code>Event</code>接口，并且定义了自己的实例属性和实例方法。</p><p>浏览器原生提供<code>KeyboardEvent</code>构造函数，用来新建键盘事件的实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> KeyboardEvent(type, options);</span><br></pre></td></tr></table></figure><p><code>KeyboardEvent</code>构造函数接受两个参数。第一个参数是字符串，表示事件类型；第二个参数是一个事件配置对象，该参数可选。除了<code>Event</code>接口提供的属性，还可以配置以下字段，它们都是可选。</p><ul><li><code>key</code>：字符串，当前按下的键，默认为空字符串。</li><li><code>code</code>：字符串，表示当前按下的键的字符串形式，默认为空字符串。</li><li><code>location</code>：整数，当前按下的键的位置，默认为<code>0</code>。</li><li><code>ctrlKey</code>：布尔值，是否按下 Ctrl 键，默认为<code>false</code>。</li><li><code>shiftKey</code>：布尔值，是否按下 Shift 键，默认为<code>false</code>。</li><li><code>altKey</code>：布尔值，是否按下 Alt 键，默认为<code>false</code>。</li><li><code>metaKey</code>：布尔值，是否按下 Meta 键，默认为<code>false</code>。</li><li><code>repeat</code>：布尔值，是否重复按键，默认为<code>false</code>。</li></ul><h1 id="KeyboardEvent-的实例属性"><a href="#KeyboardEvent-的实例属性" class="headerlink" title="KeyboardEvent 的实例属性"></a>KeyboardEvent 的实例属性</h1><h2 id="KeyboardEvent-altKey，KeyboardEvent-metaKey-ctrlKey，KeyboardEvent-metaKey，KeyboardEvent-shiftKey"><a href="#KeyboardEvent-altKey，KeyboardEvent-metaKey-ctrlKey，KeyboardEvent-metaKey，KeyboardEvent-shiftKey" class="headerlink" title="KeyboardEvent.altKey，KeyboardEvent.metaKey.ctrlKey，KeyboardEvent.metaKey，KeyboardEvent.shiftKey"></a>KeyboardEvent.altKey，KeyboardEvent.metaKey.ctrlKey，KeyboardEvent.metaKey，KeyboardEvent.shiftKey</h2><p>以下属性都是只读属性，返回一个布尔值，表示是否按下对应的键。</p><ul><li><code>KeyboardEvent.altKey</code>：是否按下 Alt 键</li><li><code>KeyboardEvent.ctrlKey</code>：是否按下 Ctrl 键</li><li><code>KeyboardEvent.metaKey</code>：是否按下 meta 键（Mac 系统是一个四瓣的小花，Windows 系统是 windows 键）</li><li><code>KeyboardEvent.shiftKey</code>：是否按下 Shift 键</li></ul><p>下面是一个示例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showChar</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;ALT: &quot;</span> + e.altKey);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;CTRL: &quot;</span> + e.ctrlKey);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Meta: &quot;</span> + e.metaKey);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Meta: &quot;</span> + e.shiftKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">&quot;keydown&quot;</span>, showChar, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><h2 id="KeyboardEvent-code"><a href="#KeyboardEvent-code" class="headerlink" title="KeyboardEvent.code"></a>KeyboardEvent.code</h2><p><code>KeyboardEvent.code</code>属性返回一个字符串，表示当前按下的键的字符串形式。该属性只读。</p><p>下面是一些常用键的字符串形式，其他键请查<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code#Code_values">文档</a>。</p><ul><li>数字键 0 - 9：返回<code>digital0</code> - <code>digital9</code></li><li>字母键 A - z：返回<code>KeyA</code> - <code>KeyZ</code></li><li>功能键 F1 - F12：返回 <code>F1</code> - <code>F12</code></li><li>方向键：返回<code>ArrowDown</code>、<code>ArrowUp</code>、<code>ArrowLeft</code>、<code>ArrowRight</code></li><li>Alt 键：返回<code>AltLeft</code>或<code>AltRight</code></li><li>Shift 键：返回<code>ShiftLeft</code>或<code>ShiftRight</code></li><li>Ctrl 键：返回<code>ControLeft</code>或<code>ControlRight</code></li></ul><h2 id="KeyboardEvent-key"><a href="#KeyboardEvent-key" class="headerlink" title="KeyboardEvent.key"></a>KeyboardEvent.key</h2><p><code>KeyboardEvent.key</code>属性返回一个字符串，表示按下的键名。该属性只读。</p><p>如果按下的键代表可打印字符，则返回这个字符，比如数字、字母。</p><p>如果按下的键代表不可打印的特殊字符，则返回预定义的键值，比如 Backspace，Tab，Enter，Shift，Control，Alt，CapsLock，Esc，Spacebar，PageUp，PageDown，End，Home，Left，Right，Up，Down，PrintScreen，Insert，Del，Win，F1 ～ F12，NumLock，Scroll 等。</p><p>如果同时按下一个控制键和一个符号键，则返回符号键的键名。比如，按下 Ctrl + a，则返回<code>a</code>；按下 Shift + a，则返回大写的<code>A</code>。</p><p>如果无法识别键名，返回字符串<code>Unidentified</code>。</p><h2 id="KeyboardEvent-location"><a href="#KeyboardEvent-location" class="headerlink" title="KeyboardEvent.location"></a>KeyboardEvent.location</h2><p><code>KeyboardEvent.location</code>属性返回一个整数，表示按下的键处在键盘的哪一个区域。它可能取以下值。</p><ul><li>0：处在键盘的主区域，或者无法判断处于哪一个区域。</li><li>1：处在键盘的左侧，只适用那些有两个位置的键（比如 Ctrl 和 Shift 键）。</li><li>2：处在键盘的右侧，只适用那些有两个位置的键（比如 Ctrl 和 Shift 键）。</li><li>3：处在数字小键盘。</li></ul><h2 id="KeyboardEvent-repeat"><a href="#KeyboardEvent-repeat" class="headerlink" title="KeyboardEvent.repeat"></a>KeyboardEvent.repeat</h2><p><code>KeyboardEvent.repeat</code>返回一个布尔值，代表该键是否被按着不放，以便判断是否重复这个键，即浏览器会持续触发<code>keydown</code>和<code>keypress</code>事件，直到用户松开手为止。</p><h1 id="KeyboardEvent-的实例方法"><a href="#KeyboardEvent-的实例方法" class="headerlink" title="KeyboardEvent 的实例方法"></a>KeyboardEvent 的实例方法</h1><h2 id="KeyboardEvent-getModifierState"><a href="#KeyboardEvent-getModifierState" class="headerlink" title="KeyboardEvent.getModifierState()"></a>KeyboardEvent.getModifierState()</h2><p><code>KeyboardEvent.getModifierState()</code>方法返回一个布尔值，表示是否按下或激活指定的功能键。它的常用参数如下。</p><ul><li><code>Alt</code>：Alt 键</li><li><code>CapsLock</code>：大写锁定键</li><li><code>Control</code>：Ctrl 键</li><li><code>Meta</code>：Meta 键</li><li><code>NumLock</code>：数字键盘开关键</li><li><code>Shift</code>：Shift 键</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (</span><br><span class="line">  event.getModifierState(<span class="string">&quot;Control&quot;</span>) +</span><br><span class="line">    event.getModifierState(<span class="string">&quot;Alt&quot;</span>) +</span><br><span class="line">    event.getModifierState(<span class="string">&quot;Meta&quot;</span>) &gt;</span><br><span class="line">  <span class="number">1</span></span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码表示，只要<code>Control</code>、<code>Alt</code>、<code>Meta</code>里面，同时按下任意两个或两个以上的键就返回。</p><h1 id="进度事件"><a href="#进度事件" class="headerlink" title="进度事件"></a>进度事件</h1><p>进度事件用来描述资源加载的进度，主要由 AJAX 请求、<code>&lt;img&gt;</code>、<code>&lt;audio&gt;</code>、<code>&lt;video&gt;</code>、<code>&lt;style&gt;</code>、<code>&lt;link&gt;</code>等外部资源的加载触发，继承了<code>ProgressEvent</code>接口。它主要包含以下几种事件。</p><ul><li><code>abort</code>：外部资源中止加载时（比如用户取消）触发。如果发生错误导致中止，不会触发该事件。</li><li><code>error</code>：由于错误导致外部资源无法加载时触发。</li><li><code>load</code>：外部资源加载成功时触发。</li><li><code>loadstart</code>：外部资源开始加载时触发。</li><li><code>loadend</code>：外部资源停止加载时触发，发生顺序排在<code>error</code>、<code>abort</code>、<code>load</code>等事件的后面。</li><li><code>progress</code>：外部资源加载过程中不断触发。</li><li><code>timeout</code>：加载超时时触发。</li></ul><p>注意，除了资源下载，文件上传也存在这些事件。</p><p>下面是一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">image.addEventListener(<span class="string">&quot;load&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  image.classList.add(<span class="string">&quot;finished&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">image.addEventListener(<span class="string">&quot;error&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  image.style.display = <span class="string">&quot;none&quot;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码在图片元素加载完成后，为图片元素添加一个<code>finished</code>的 Class。如果加载失败，就把图片元素的样式设置为不显示。</p><p>有时候，图片加载会在脚本运行之前就完成，尤其是当脚本放置在网页底部的时候，因此有可能<code>load</code>和<code>error</code>事件的监听函数根本不会执行。所以，比较可靠的方式，是用<code>complete</code>属性先判断一下是否加载完成。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loaded</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (image.complete) &#123;</span><br><span class="line">  loaded();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  image.addEventListener(<span class="string">&quot;load&quot;</span>, loaded);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 DOM 的元素节点没有提供是否加载错误的属性，所以<code>error</code>事件的监听函数最好放在<code>&lt;img&gt;</code>元素的 HTML 代码中，这样才能保证发生加载错误时百分之百会执行。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/wrong/url&quot;</span> <span class="attr">onerror</span>=<span class="string">&quot;this.style.display=&#x27;none&#x27;;&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p><code>loadend</code>事件的监听函数，可以用来取代<code>abort</code>事件、<code>load</code>事件、<code>error</code>事件的监听函数，因为它总是在这些事件之后发生。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">req.addEventListener(<span class="string">&quot;loadend&quot;</span>, loadEnd, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadEnd</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;传输结束，成功失败未知&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>loadend</code>事件本身不提供关于进度结束的原因，但可以用它来做所有加载结束场景都需要做的一些操作。</p><p>另外，<code>error</code>事件有一个特殊的性质，就是不会冒泡。所以，子元素的<code>error</code>事件，不会触发父元素的<code>error</code>事件监听函数。</p><h1 id="ProgressEvent-接口"><a href="#ProgressEvent-接口" class="headerlink" title="ProgressEvent 接口"></a>ProgressEvent 接口</h1><p><code>ProgressEvent</code>接口主要用来描述外部资源加载的进度，比如 AJAX 加载、<code>&lt;img&gt;</code>、<code>&lt;video&gt;</code>、<code>&lt;style&gt;</code>、<code>&lt;link&gt;</code>等外部资源加载。进度相关的事件都继承了这个接口。</p><p>浏览器原生提供了<code>ProgressEvent()</code>构造函数，用来生成事件实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ProgressEvent(type, options);</span><br></pre></td></tr></table></figure><p><code>ProgressEvent()</code>构造函数接受两个参数。第一个参数是字符串，表示事件的类型，这个参数是必须的。第二个参数是一个配置对象，表示事件的属性，该参数可选。配置对象除了可以使用<code>Event</code>接口的配置属性，还可以使用下面的属性，所有这些属性都是可选的。</p><ul><li><code>lengthComputable</code>：布尔值，表示加载的总量是否可以计算，默认是<code>false</code>。</li><li><code>loaded</code>：整数，表示已经加载的量，默认是<code>0</code>。</li><li><code>total</code>：整数，表示需要加载的总量，默认是<code>0</code>。</li></ul><p><code>ProgressEvent</code>具有对应的实例属性。</p><ul><li><code>ProgressEvent.lengthComputable</code></li><li><code>ProgressEvent.loaded</code></li><li><code>ProgressEvent.total</code></li></ul><p>如果<code>ProgressEvent.lengthComputable</code>为<code>false</code>，<code>ProgressEvent.total</code>实际上是没有意义的。</p><p>下面是一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> ProgressEvent(<span class="string">&quot;load&quot;</span>, &#123;</span><br><span class="line">  lengthComputable: <span class="literal">true</span>,</span><br><span class="line">  loaded: <span class="number">30</span>,</span><br><span class="line">  total: <span class="number">100</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">&quot;load&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;已经加载：&quot;</span> + (e.loaded / e.total) * <span class="number">100</span> + <span class="string">&quot;%&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.dispatchEvent(p);</span><br><span class="line"><span class="comment">// 已经加载：30%</span></span><br></pre></td></tr></table></figure><p>上面代码先构造一个<code>load</code>事件，抛出后被监听函数捕捉到。</p><p>下面是一个实际的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">xhr.addEventListener(<span class="string">&quot;progress&quot;</span>, updateProgress, <span class="literal">false</span>);</span><br><span class="line">xhr.addEventListener(<span class="string">&quot;load&quot;</span>, transferComplete, <span class="literal">false</span>);</span><br><span class="line">xhr.addEventListener(<span class="string">&quot;error&quot;</span>, transferFailed, <span class="literal">false</span>);</span><br><span class="line">xhr.addEventListener(<span class="string">&quot;abort&quot;</span>, transferCanceled, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">xhr.open();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateProgress</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (e.lengthComputable) &#123;</span><br><span class="line">    <span class="keyword">var</span> percentComplete = e.loaded / e.total;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;不能计算进度&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">transferComplete</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;传输结束&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">transferFailed</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;传输过程中发生错误&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">transferCanceled</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;用户取消了传输&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是下载过程的进度事件，还存在上传过程的进度事件。这时所有监听函数都要放在<code>XMLHttpRequest.upload</code>对象上面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">xhr.upload.addEventListener(<span class="string">&quot;progress&quot;</span>, updateProgress, <span class="literal">false</span>);</span><br><span class="line">xhr.upload.addEventListener(<span class="string">&quot;load&quot;</span>, transferComplete, <span class="literal">false</span>);</span><br><span class="line">xhr.upload.addEventListener(<span class="string">&quot;error&quot;</span>, transferFailed, <span class="literal">false</span>);</span><br><span class="line">xhr.upload.addEventListener(<span class="string">&quot;abort&quot;</span>, transferCanceled, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">xhr.open();</span><br></pre></td></tr></table></figure><h1 id="拖拉事件"><a href="#拖拉事件" class="headerlink" title="拖拉事件"></a>拖拉事件</h1><p>拖拉（drag）指的是，用户在某个对象上按下鼠标键不放，拖动它到另一个位置，然后释放鼠标键，将该对象放在那里。</p><p>拖拉的对象有好几种，包括元素节点、图片、链接、选中的文字等等。在网页中，除了元素节点默认不可以拖拉，其他（图片、链接、选中的文字）都是可以直接拖拉的。为了让元素节点可拖拉，可以将该节点的<code>draggable</code>属性设为<code>true</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">draggable</span>=<span class="string">&quot;true&quot;</span>&gt;</span>此区域可拖拉<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>draggable</code>属性可用于任何元素节点，但是图片（<code>&lt;img&gt;</code>）和链接（<code>&lt;a&gt;</code>）不加这个属性，就可以拖拉。对于它们，用到这个属性的时候，往往是将其设为<code>false</code>，防止拖拉这两种元素。</p><p>注意，一旦某个元素节点的<code>draggable</code>属性设为<code>true</code>，就无法再用鼠标选中该节点内部的文字或子节点了。</p><p>当元素节点或选中的文本被拖拉时，就会持续触发拖拉事件，包括以下一些事件。</p><ul><li><code>drag</code>：拖拉过程中，在被拖拉的节点上持续触发（相隔几百毫秒）。</li><li><code>dragstart</code>：用户开始拖拉时，在被拖拉的节点上触发，该事件的<code>target</code>属性是被拖拉的节点。通常应该在这个事件的监听函数中，指定拖拉的数据。</li><li><code>dragend</code>：拖拉结束时（释放鼠标键或按下 ESC 键）在被拖拉的节点上触发，该事件的<code>target</code>属性是被拖拉的节点。它与<code>dragstart</code>事件，在同一个节点上触发。不管拖拉是否跨窗口，或者中途被取消，<code>dragend</code>事件总是会触发的。</li><li><code>dragenter</code>：拖拉进入当前节点时，在当前节点上触发一次，该事件的<code>target</code>属性是当前节点。通常应该在这个事件的监听函数中，指定是否允许在当前节点放下（drop）拖拉的数据。如果当前节点没有该事件的监听函数，或者监听函数不执行任何操作，就意味着不允许在当前节点放下数据。在视觉上显示拖拉进入当前节点，也是在这个事件的监听函数中设置。</li><li><code>dragover</code>：拖拉到当前节点上方时，在当前节点上持续触发（相隔几百毫秒），该事件的<code>target</code>属性是当前节点。该事件与<code>dragenter</code>事件的区别是，<code>dragenter</code>事件在进入该节点时触发，然后只要没有离开这个节点，<code>dragover</code>事件会持续触发。</li><li><code>dragleave</code>：拖拉操作离开当前节点范围时，在当前节点上触发，该事件的<code>target</code>属性是当前节点。如果要在视觉上显示拖拉离开操作当前节点，就在这个事件的监听函数中设置。</li><li><code>drop</code>：被拖拉的节点或选中的文本，释放到目标节点时，在目标节点上触发。注意，如果当前节点不允许<code>drop</code>，即使在该节点上方松开鼠标键，也不会触发该事件。如果用户按下 ESC 键，取消这个操作，也不会触发该事件。该事件的监听函数负责取出拖拉数据，并进行相关处理。</li></ul><p>下面的例子展示，如何动态改变被拖动节点的背景色。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">div.addEventListener(</span><br><span class="line">  <span class="string">&quot;dragstart&quot;</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.style.backgroundColor = <span class="string">&quot;red&quot;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">div.addEventListener(</span><br><span class="line">  <span class="string">&quot;dragend&quot;</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.style.backgroundColor = <span class="string">&quot;green&quot;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>div</code>节点被拖动时，背景色会变为红色，拖动结束，又变回绿色。</p><p>下面是一个例子，展示如何实现将一个节点从当前父节点，拖拉到另一个父节点中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* HTML 代码如下</span></span><br><span class="line"><span class="comment"> &lt;div class=&quot;dropzone&quot;&gt;</span></span><br><span class="line"><span class="comment">   &lt;div id=&quot;draggable&quot; draggable=&quot;true&quot;&gt;</span></span><br><span class="line"><span class="comment">     该节点可拖拉</span></span><br><span class="line"><span class="comment">   &lt;/div&gt;</span></span><br><span class="line"><span class="comment"> &lt;/div&gt;</span></span><br><span class="line"><span class="comment"> &lt;div class=&quot;dropzone&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="comment"> &lt;div class=&quot;dropzone&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="comment"> &lt;div class=&quot;dropzone&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 被拖拉节点</span></span><br><span class="line"><span class="keyword">var</span> dragged;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(</span><br><span class="line">  <span class="string">&quot;dragstart&quot;</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 保存被拖拉节点</span></span><br><span class="line">    dragged = event.target;</span><br><span class="line">    <span class="comment">// 被拖拉节点的背景色变透明</span></span><br><span class="line">    event.target.style.opacity = <span class="number">0.5</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(</span><br><span class="line">  <span class="string">&quot;dragend&quot;</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 被拖拉节点的背景色恢复正常</span></span><br><span class="line">    event.target.style.opacity = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(</span><br><span class="line">  <span class="string">&quot;dragover&quot;</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 防止拖拉效果被重置，允许被拖拉的节点放入目标节点</span></span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(</span><br><span class="line">  <span class="string">&quot;dragenter&quot;</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 目标节点的背景色变紫色</span></span><br><span class="line">    <span class="comment">// 由于该事件会冒泡，所以要过滤节点</span></span><br><span class="line">    <span class="keyword">if</span> (event.target.className === <span class="string">&quot;dropzone&quot;</span>) &#123;</span><br><span class="line">      event.target.style.background = <span class="string">&quot;purple&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(</span><br><span class="line">  <span class="string">&quot;dragleave&quot;</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 目标节点的背景色恢复原样</span></span><br><span class="line">    <span class="keyword">if</span> (event.target.className === <span class="string">&quot;dropzone&quot;</span>) &#123;</span><br><span class="line">      event.target.style.background = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(</span><br><span class="line">  <span class="string">&quot;drop&quot;</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 防止事件默认行为（比如某些元素节点上可以打开链接），</span></span><br><span class="line">    event.preventDefault();</span><br><span class="line">    <span class="keyword">if</span> (event.target.className === <span class="string">&quot;dropzone&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">// 恢复目标节点背景色</span></span><br><span class="line">      event.target.style.background = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      <span class="comment">// 将被拖拉节点插入目标节点</span></span><br><span class="line">      dragged.parentNode.removeChild(dragged);</span><br><span class="line">      event.target.appendChild(dragged);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>关于拖拉事件，有以下几个注意点。</p><ul><li>拖拉过程只触发以上这些拖拉事件，尽管鼠标在移动，但是鼠标事件不会触发。</li><li>将文件从操作系统拖拉进浏览器，不会触发<code>dragstart</code>和<code>dragend</code>事件。</li><li><code>dragenter</code>和<code>dragover</code>事件的监听函数，用来取出拖拉的数据（即允许放下被拖拉的元素）。由于网页的大部分区域不适合作为放下拖拉元素的目标节点，所以这两个事件的默认设置为当前节点不允许接受被拖拉的元素。如果想要在目标节点上放下的数据，首先必须阻止这两个事件的默认行为。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ondragover</span>=<span class="string">&quot;return false&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">ondragover</span>=<span class="string">&quot;event.preventDefault()&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面代码中，如果不取消拖拉事件或者阻止默认行为，就不能在<code>div</code>节点上放下被拖拉的节点。</p><h1 id="DragEvent-接口"><a href="#DragEvent-接口" class="headerlink" title="DragEvent 接口"></a>DragEvent 接口</h1><p>拖拉事件都继承了<code>DragEvent</code>接口，这个接口又继承了<code>MouseEvent</code>接口和<code>Event</code>接口。</p><p>浏览器原生提供一个<code>DragEvent()</code>构造函数，用来生成拖拉事件的实例对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> DragEvent(type, options);</span><br></pre></td></tr></table></figure><p><code>DragEvent()</code>构造函数接受两个参数，第一个参数是字符串，表示事件的类型，该参数必须；第二个参数是事件的配置对象，用来设置事件的属性，该参数可选。配置对象除了接受<code>MouseEvent</code>接口和<code>Event</code>接口的配置属性，还可以设置<code>dataTransfer</code>属性要么是<code>null</code>，要么是一个<code>DataTransfer</code>接口的实例。</p><p><code>DataTransfer</code>的实例对象用来读写拖拉事件中传输的数据，详见下文《DataTransfer 接口》的部分。</p><h1 id="DataTransfer-接口概述"><a href="#DataTransfer-接口概述" class="headerlink" title="DataTransfer 接口概述"></a>DataTransfer 接口概述</h1><p>所有拖拉事件的实例都有一个<code>DragEvent.dataTransfer</code>属性，用来读写需要传递的数据。这个属性的值是一个<code>DataTransfer</code>接口的实例。</p><p>浏览器原生提供一个<code>DataTransfer()</code>构造函数，用来生成<code>DataTransfer</code>实例对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dataTrans = <span class="keyword">new</span> DataTransfer();</span><br></pre></td></tr></table></figure><p><code>DataTransfer()</code>构造函数不接受参数。</p><p>拖拉的数据分成两方面：数据的种类（又称格式）和数据的值。数据的种类是一个 MIME 字符串（比如<code>text/plain</code>、<code>image/jpeg</code>），数据的值是一个字符串。一般来说，如果拖拉一段文本，则数据默认就是那段文本；如果拖拉一个链接，则数据默认就是链接的 URL。</p><p>拖拉事件开始时，开发者可以提供数据类型和数据值。拖拉过程中，开发者通过<code>dragenter</code>和<code>dragover</code>事件的监听函数，检查数据类型，以确定是否允许放下（drop）被拖拉的对象。比如，在只允许放下链接的区域，检查拖拉的数据类型是否为<code>text/uri-list</code>。</p><p>发生<code>drop</code>事件时，监听函数取出拖拉的数据，对其进行处理。</p><h1 id="DataTransfer-的实例属性"><a href="#DataTransfer-的实例属性" class="headerlink" title="DataTransfer 的实例属性"></a>DataTransfer 的实例属性</h1><h2 id="DataTransfer-dropEffect"><a href="#DataTransfer-dropEffect" class="headerlink" title="DataTransfer.dropEffect"></a>DataTransfer.dropEffect</h2><p><code>DataTransfer.dropEffect</code>属性用来设置放下（drop）被拖拉节点时的效果，会影响到拖拉经过相关区域时鼠标的形状。它可能取下面的值。</p><ul><li>copy：复制被拖拉的节点</li><li>move：移动被拖拉的节点</li><li>link：创建指向被拖拉的节点的链接</li><li>none：无法放下被拖拉的节点</li></ul><p>除了上面这些值，设置其他的值都是无效的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">target.addEventListener(<span class="string">&quot;dragover&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line">  e.stopPropagation();</span><br><span class="line">  e.dataTransfer.dropEffect = <span class="string">&quot;copy&quot;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，被拖拉元素一旦<code>drop</code>，接受的区域会复制该节点。</p><p><code>dropEffect</code>属性一般在<code>dragenter</code>和<code>dragover</code>事件的监听函数中设置，对于<code>dragstart</code>、<code>drag</code>、<code>dragleave</code>这三个事件，该属性不起作用。因为该属性只对接受被拖拉的节点的区域有效，对被拖拉的节点本身是无效的。进入目标区域后，拖拉行为会初始化成设定的效果。</p><h2 id="DataTransfer-effectAllowed"><a href="#DataTransfer-effectAllowed" class="headerlink" title="DataTransfer.effectAllowed"></a>DataTransfer.effectAllowed</h2><p><code>DataTransfer.effectAllowed</code>属性设置本次拖拉中允许的效果。它可能取下面的值。</p><ul><li>copy：复制被拖拉的节点</li><li>move：移动被拖拉的节点</li><li>link：创建指向被拖拉节点的链接</li><li>copyLink：允许<code>copy</code>或<code>link</code></li><li>copyMove：允许<code>copy</code>或<code>move</code></li><li>linkMove：允许<code>link</code>或<code>move</code></li><li>all：允许所有效果</li><li>none：无法放下被拖拉的节点</li><li>uninitialized：默认值，等同于<code>all</code></li></ul><p>如果某种效果是不允许的，用户就无法在目标节点中达成这种效果。</p><p>这个属性与<code>dropEffect</code>属性是同一件事的两个方面。前者设置被拖拉的节点允许的效果，后者设置接受拖拉的区域的效果，它们往往配合使用。</p><p><code>dragstart</code>事件的监听函数，可以用来设置这个属性。其他事件的监听函数里面设置这个属性是无效的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">source.addEventListener(<span class="string">&quot;dragstart&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  e.dataTransfer.effectAllowed = <span class="string">&quot;move&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">target.addEventListener(<span class="string">&quot;dragover&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  ev.dataTransfer.dropEffect = <span class="string">&quot;move&quot;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>只要<code>dropEffect</code>属性和<code>effectAllowed</code>属性之中，有一个为<code>none</code>，就无法在目标节点上完成<code>drop</code>操作。</p><h2 id="DataTransfer-files"><a href="#DataTransfer-files" class="headerlink" title="DataTransfer.files"></a>DataTransfer.files</h2><p><code>DataTransfer.files</code>属性是一个 FileList 对象，包含一组本地文件，可以用来在拖拉操作中传送。如果本次拖拉不涉及文件，则该属性为空的 FileList 对象。</p><p>下面就是一个接收拖拉文件的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;output&quot; style=&quot;min-height: 200px;border: 1px solid black;&quot;&gt;</span></span><br><span class="line"><span class="comment">//   文件拖拉到这里</span></span><br><span class="line"><span class="comment">// &lt;/div&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">&quot;output&quot;</span>);</span><br><span class="line"></span><br><span class="line">div.addEventListener(</span><br><span class="line">  <span class="string">&quot;dragenter&quot;</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    div.textContent = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    event.stopPropagation();</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">div.addEventListener(</span><br><span class="line">  <span class="string">&quot;dragover&quot;</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    event.stopPropagation();</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">div.addEventListener(</span><br><span class="line">  <span class="string">&quot;drop&quot;</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    event.stopPropagation();</span><br><span class="line">    event.preventDefault();</span><br><span class="line">    <span class="keyword">var</span> files = event.dataTransfer.files;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; files.length; i++) &#123;</span><br><span class="line">      div.textContent += files[i].name + <span class="string">&quot; &quot;</span> + files[i].size + <span class="string">&quot;字节\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上面代码中，通过<code>dataTransfer.files</code>属性读取被拖拉的文件的信息。如果想要读取文件内容，就要使用<code>FileReader</code>对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">div.addEventListener(<span class="string">&quot;drop&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line">  e.stopPropagation();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> fileList = e.dataTransfer.files;</span><br><span class="line">  <span class="keyword">if</span> (fileList.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> file = fileList[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line">    reader.onloadend = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (e.target.readyState === FileReader.DONE) &#123;</span><br><span class="line">        <span class="keyword">var</span> content = reader.result;</span><br><span class="line">        div.innerHTML = <span class="string">&quot;File: &quot;</span> + file.name + <span class="string">&quot;\n\n&quot;</span> + content;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    reader.readAsBinaryString(file);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="DataTransfer-types"><a href="#DataTransfer-types" class="headerlink" title="DataTransfer.types"></a>DataTransfer.types</h2><p><code>DataTransfer.types</code>属性是一个只读的数组，每个成员是一个字符串，里面是拖拉的数据格式（通常是 MIME 值）。比如，如果拖拉的是文字，对应的成员就是<code>text/plain</code>。</p><p>下面是一个例子，通过检查<code>dataTransfer</code>属性的类型，决定是否允许在当前节点执行<code>drop</code>操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">contains</span>(<span class="params">list, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; list.length; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (list[i] === value) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doDragOver</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> isLink = contains(event.dataTransfer.types, <span class="string">&quot;text/uri-list&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (isLink) event.preventDefault();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，只有当被拖拉的节点是一个链接时，才允许在当前节点放下。</p><h2 id="DataTransfer-items"><a href="#DataTransfer-items" class="headerlink" title="DataTransfer.items"></a>DataTransfer.items</h2><p><code>DataTransfer.items</code>属性返回一个类似数组的只读对象（DataTransferItemList 实例），每个成员就是本次拖拉的一个对象（DataTransferItem 实例）。如果本次拖拉不包含对象，则返回一个空对象。</p><p>DataTransferItemList 实例具有以下的属性和方法。</p><ul><li><code>length</code>：返回成员的数量</li><li><code>add(data, type)</code>：增加一个指定内容和类型（比如<code>text/html</code>和<code>text/plain</code>）的字符串作为成员</li><li><code>add(file)</code>：<code>add</code>方法的另一种用法，增加一个文件作为成员</li><li><code>remove(index)</code>：移除指定位置的成员</li><li><code>clear()</code>：移除所有的成员</li></ul><p>DataTransferItem 实例具有以下的属性和方法。</p><ul><li><code>kind</code>：返回成员的种类（<code>string</code>还是<code>file</code>）。</li><li><code>type</code>：返回成员的类型（通常是 MIME 值）。</li><li><code>getAsFile()</code>：如果被拖拉是文件，返回该文件，否则返回<code>null</code>。</li><li><code>getAsString(callback)</code>：如果被拖拉的是字符串，将该字符传入指定的回调函数处理。该方法是异步的，所以需要传入回调函数。</li></ul><p>下面是一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">div.addEventListener(<span class="string">&quot;drop&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line">  <span class="keyword">if</span> (e.dataTransfer.items != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; e.dataTransfer.items.length; i++) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(</span><br><span class="line">        e.dataTransfer.items[i].kind + <span class="string">&quot;: &quot;</span> + e.dataTransfer.items[i].type</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="DataTransfer-的实例方法"><a href="#DataTransfer-的实例方法" class="headerlink" title="DataTransfer 的实例方法"></a>DataTransfer 的实例方法</h1><h2 id="DataTransfer-setData"><a href="#DataTransfer-setData" class="headerlink" title="DataTransfer.setData()"></a>DataTransfer.setData()</h2><p><code>DataTransfer.setData()</code>方法用来设置拖拉事件所带有的数据。该方法没有返回值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event.dataTransfer.setData(<span class="string">&quot;text/plain&quot;</span>, <span class="string">&quot;Text to drag&quot;</span>);</span><br></pre></td></tr></table></figure><p>上面代码为当前的拖拉事件加入纯文本数据。</p><p>该方法接受两个参数，都是字符串。第一个参数表示数据类型（比如<code>text/plain</code>），第二个参数是具体数据。如果指定类型的数据在<code>dataTransfer</code>属性不存在，那么这些数据将被加入，否则原有的数据将被新数据替换。</p><p>如果是拖拉文本框或者拖拉选中的文本，会默认将对应的文本数据，添加到<code>dataTransfer</code>属性，不用手动指定。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">draggable</span>=<span class="string">&quot;true&quot;</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面代码中，拖拉这个<code>&lt;div&gt;</code>元素会自动带上文本数据<code>aaa</code>。</p><p>使用<code>setData</code>方法，可以替换到原有数据。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">  <span class="attr">draggable</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">ondragstart</span>=<span class="string">&quot;event.dataTransfer.setData(&#x27;text/plain&#x27;, &#x27;bbb&#x27;)&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  aaa</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面代码中，拖拉数据实际上是<code>bbb</code>，而不是<code>aaa</code>。</p><p>下面是添加其他类型的数据。由于<code>text/plain</code>是最普遍支持的格式，为了保证兼容性，建议最后总是保存一份纯文本格式的数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dt = event.dataTransfer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加链接</span></span><br><span class="line">dt.setData(<span class="string">&quot;text/uri-list&quot;</span>, <span class="string">&quot;http://www.example.com&quot;</span>);</span><br><span class="line">dt.setData(<span class="string">&quot;text/plain&quot;</span>, <span class="string">&quot;http://www.example.com&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 HTML 代码</span></span><br><span class="line">dt.setData(<span class="string">&quot;text/html&quot;</span>, <span class="string">&quot;Hello there, &lt;strong&gt;stranger&lt;/strong&gt;&quot;</span>);</span><br><span class="line">dt.setData(<span class="string">&quot;text/plain&quot;</span>, <span class="string">&quot;Hello there, &lt;strong&gt;stranger&lt;/strong&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加图像的 URL</span></span><br><span class="line">dt.setData(<span class="string">&quot;text/uri-list&quot;</span>, imageurl);</span><br><span class="line">dt.setData(<span class="string">&quot;text/plain&quot;</span>, imageurl);</span><br></pre></td></tr></table></figure><p>可以一次提供多种格式的数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dt = event.dataTransfer;</span><br><span class="line">dt.setData(<span class="string">&quot;application/x-bookmark&quot;</span>, bookmarkString);</span><br><span class="line">dt.setData(<span class="string">&quot;text/uri-list&quot;</span>, <span class="string">&quot;http://www.example.com&quot;</span>);</span><br><span class="line">dt.setData(<span class="string">&quot;text/plain&quot;</span>, <span class="string">&quot;http://www.example.com&quot;</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，通过在同一个事件上面，存放三种类型的数据，使得拖拉事件可以在不同的对象上面，<code>drop</code>不同的值。注意，第一种格式是一个自定义格式，浏览器默认无法读取，这意味着，只有某个部署了特定代码的节点，才可能<code>drop</code>（读取到）这个数据。</p><h2 id="DataTransfer-getData"><a href="#DataTransfer-getData" class="headerlink" title="DataTransfer.getData()"></a>DataTransfer.getData()</h2><p><code>DataTransfer.getData()</code>方法接受一个字符串（表示数据类型）作为参数，返回事件所带的指定类型的数据（通常是用<code>setData</code>方法添加的数据）。如果指定类型的数据不存在，则返回空字符串。通常只有<code>drop</code>事件触发后，才能取出数据。</p><p>下面是一个<code>drop</code>事件的监听函数，用来取出指定类型的数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onDrop</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = event.dataTransfer.getData(<span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line">  event.target.textContent = data;</span><br><span class="line">  event.preventDefault();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码取出拖拉事件的文本数据，将其替换成当前节点的文本内容。注意，这时还必须取消浏览器的默认行为，因为假如用户拖拉的是一个链接，浏览器默认会在当前窗口打开这个链接。</p><p><code>getData</code>方法返回的是一个字符串，如果其中包含多项数据，就必须手动解析。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doDrop</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> lines = event.dataTransfer.getData(<span class="string">&quot;text/uri-list&quot;</span>).split(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> line <span class="keyword">of</span> lines) &#123;</span><br><span class="line">    <span class="keyword">let</span> link = <span class="built_in">document</span>.createElement(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    link.href = line;</span><br><span class="line">    link.textContent = line;</span><br><span class="line">    event.target.appendChild(link);</span><br><span class="line">  &#125;</span><br><span class="line">  event.preventDefault();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>getData</code>方法返回的是一组链接，就必须自行解析。</p><p>类型值指定为<code>URL</code>，可以取出第一个有效链接。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> link = event.dataTransfer.getData(<span class="string">&quot;URL&quot;</span>);</span><br></pre></td></tr></table></figure><p>下面的例子是从多种类型的数据里面取出数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doDrop</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> types = event.dataTransfer.types;</span><br><span class="line">  <span class="keyword">var</span> supportedTypes = [<span class="string">&quot;text/uri-list&quot;</span>, <span class="string">&quot;text/plain&quot;</span>];</span><br><span class="line">  types = supportedTypes.filter(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    types.includes(value);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">if</span> (types.length) &#123;</span><br><span class="line">    <span class="keyword">var</span> data = event.dataTransfer.getData(types[<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  event.preventDefault();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DataTransfer-clearData"><a href="#DataTransfer-clearData" class="headerlink" title="DataTransfer.clearData()"></a>DataTransfer.clearData()</h2><p><code>DataTransfer.clearData()</code>方法接受一个字符串（表示数据类型）作为参数，删除事件所带的指定类型的数据。如果没有指定类型，则删除所有数据。如果指定类型不存在，则调用该方法不会产生任何效果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event.dataTransfer.clearData(<span class="string">&quot;text/uri-list&quot;</span>);</span><br></pre></td></tr></table></figure><p>上面代码清除事件所带的<code>text/uri-list</code>类型的数据。</p><p>该方法不会移除拖拉的文件，因此调用该方法后，<code>DataTransfer.types</code>属性可能依然会返回<code>Files</code>类型（前提是存在文件拖拉）。</p><p>注意，该方法只能在<code>dragstart</code>事件的监听函数之中使用，因为这是拖拉操作的数据唯一可写的时机。</p><h2 id="DataTransfer-setDragImage"><a href="#DataTransfer-setDragImage" class="headerlink" title="DataTransfer.setDragImage()"></a>DataTransfer.setDragImage()</h2><p>拖动过程中（<code>dragstart</code>事件触发后），浏览器会显示一张图片跟随鼠标一起移动，表示被拖动的节点。这张图片是自动创造的，通常显示为被拖动节点的外观，不需要自己动手设置。</p><p><code>DataTransfer.setDragImage()</code>方法可以自定义这张图片。它接受三个参数。第一个是<code>&lt;img&gt;</code>节点或者<code>&lt;canvas&gt;</code>节点，如果省略或为<code>null</code>，则使用被拖动的节点的外观；第二个和第三个参数为鼠标相对于该图片左上角的横坐标和右坐标。</p><p>下面是一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* HTML 代码如下</span></span><br><span class="line"><span class="comment"> &lt;div id=&quot;drag-with-image&quot; class=&quot;dragdemo&quot; draggable=&quot;true&quot;&gt;</span></span><br><span class="line"><span class="comment">   drag me</span></span><br><span class="line"><span class="comment"> &lt;/div&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">&quot;drag-with-image&quot;</span>);</span><br><span class="line">div.addEventListener(</span><br><span class="line">  <span class="string">&quot;dragstart&quot;</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> img = <span class="built_in">document</span>.createElement(<span class="string">&quot;img&quot;</span>);</span><br><span class="line">    img.src = <span class="string">&quot;http://path/to/img&quot;</span>;</span><br><span class="line">    e.dataTransfer.setDragImage(img, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h1 id="触摸操作概述"><a href="#触摸操作概述" class="headerlink" title="触摸操作概述"></a>触摸操作概述</h1><p>浏览器的触摸 API 由三个部分组成。</p><ul><li>Touch：一个触摸点</li><li>TouchList：多个触摸点的集合</li><li>TouchEvent：触摸引发的事件实例</li></ul><p><code>Touch</code>接口的实例对象用来触摸点（一根手指或者一根触摸笔），包括位置、大小、形状、压力、目标元素等属性。有时，触摸动作由多个触摸点（多根手指）组成，多个触摸点的集合由<code>TouchList</code>接口的实例对象表示。<code>TouchEvent</code>接口的实例对象代表由触摸引发的事件，只有触摸屏才会引发这一类事件。</p><p>很多时候，触摸事件和鼠标事件同时触发，即使这个时候并没有用到鼠标。这是为了让那些只定义鼠标事件、没有定义触摸事件的代码，在触摸屏的情况下仍然能用。如果想避免这种情况，可以用<code>event.preventDefault</code>方法阻止发出鼠标事件。</p><h1 id="Touch-接口"><a href="#Touch-接口" class="headerlink" title="Touch 接口"></a>Touch 接口</h1><h2 id="Touch-接口概述"><a href="#Touch-接口概述" class="headerlink" title="Touch 接口概述"></a>Touch 接口概述</h2><p>Touch 接口代表单个触摸点。触摸点可能是一根手指，也可能是一根触摸笔。</p><p>浏览器原生提供<code>Touch</code>构造函数，用来生成<code>Touch</code>实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> touch = <span class="keyword">new</span> Touch(touchOptions);</span><br></pre></td></tr></table></figure><p><code>Touch</code>构造函数接受一个配置对象作为参数，它有以下属性。</p><ul><li><code>identifier</code>：必需，类型为整数，表示触摸点的唯一 ID。</li><li><code>target</code>：必需，类型为元素节点，表示触摸点开始时所在的网页元素。</li><li><code>clientX</code>：可选，类型为数值，表示触摸点相对于浏览器窗口左上角的水平距离，默认为 0。</li><li><code>clientY</code>：可选，类型为数值，表示触摸点相对于浏览器窗口左上角的垂直距离，默认为 0。</li><li><code>screenX</code>：可选，类型为数值，表示触摸点相对于屏幕左上角的水平距离，默认为 0。</li><li><code>screenY</code>：可选，类型为数值，表示触摸点相对于屏幕左上角的垂直距离，默认为 0。</li><li><code>pageX</code>：可选，类型为数值，表示触摸点相对于网页左上角的水平位置（即包括页面的滚动距离），默认为 0。</li><li><code>pageY</code>：可选，类型为数值，表示触摸点相对于网页左上角的垂直位置（即包括页面的滚动距离），默认为 0。</li><li><code>radiusX</code>：可选，类型为数值，表示触摸点周围受到影响的椭圆范围的 X 轴半径，默认为 0。</li><li><code>radiusY</code>：可选：类型为数值，表示触摸点周围受到影响的椭圆范围的 Y 轴半径，默认为 0。</li><li><code>rotationAngle</code>：可选，类型为数值，表示触摸区域的椭圆的旋转角度，单位为度数，在 0 到 90 度之间，默认值为 0。</li><li><code>force</code>：可选，类型为数值，范围在<code>0</code>到<code>1</code>之间，表示触摸压力。<code>0</code>代表没有压力，<code>1</code>代表硬件所能识别的最大压力，默认为<code>0</code>。</li></ul><h2 id="Touch-接口的实例属性"><a href="#Touch-接口的实例属性" class="headerlink" title="Touch 接口的实例属性"></a>Touch 接口的实例属性</h2><p><strong>（1）Touch.identifier</strong></p><p><code>Touch.identifier</code>属性返回一个整数，表示触摸点的唯一 ID。这个值在整个触摸过程保持不变，直到触摸事件结束。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">someElement.addEventListener(</span><br><span class="line">  <span class="string">&quot;touchmove&quot;</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; e.changedTouches.length; i++) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(e.changedTouches[i].identifier);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>（2）Touch.screenX，Touch.screenY，Touch.clientX，Touch.clientY，pageX，pageY</strong></p><p><code>Touch.screenX</code>属性和<code>Touch.screenY</code>属性，分别表示触摸点相对于屏幕左上角的横坐标和纵坐标，与页面是否滚动无关。</p><p><code>Touch.clientX</code>属性和<code>Touch.clientY</code>属性，分别表示触摸点相对于浏览器视口左上角的横坐标和纵坐标，与页面是否滚动无关。</p><p><code>Touch.pageX</code>属性和<code>Touch.pageY</code>属性，分别表示触摸点相对于当前页面左上角的横坐标和纵坐标，包含了页面滚动带来的位移。</p><p><strong>（3）Touch.radiusX，Touch.radiusY，Touch.rotationAngle</strong></p><p><code>Touch.radiusX</code>属性和<code>Touch.radiusY</code>属性，分别返回触摸点周围受到影响的椭圆范围的 X 轴半径和 Y 轴半径，单位为像素。乘以 2 就可以得到触摸范围的宽度和高度。</p><p><code>Touch.rotationAngle</code>属性表示触摸区域的椭圆的旋转角度，单位为度数，在<code>0</code>到<code>90</code>度之间。</p><p>上面这三个属性共同定义了用户与屏幕接触的区域，对于描述手指这一类非精确的触摸，很有帮助。指尖接触屏幕，触摸范围会形成一个椭圆，这三个属性就用来描述这个椭圆区域。</p><p>下面是一个示例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">div.addEventListener(<span class="string">&quot;touchstart&quot;</span>, rotate);</span><br><span class="line">div.addEventListener(<span class="string">&quot;touchmove&quot;</span>, rotate);</span><br><span class="line">div.addEventListener(<span class="string">&quot;touchend&quot;</span>, rotate);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rotate</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> touch = e.changedTouches.item(<span class="number">0</span>);</span><br><span class="line">  e.preventDefault();</span><br><span class="line"></span><br><span class="line">  src.style.width = touch.radiusX * <span class="number">2</span> + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">  src.style.height = touch.radiusY * <span class="number">2</span> + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">  src.style.transform = <span class="string">&quot;rotate(&quot;</span> + touch.rotationAngle + <span class="string">&quot;deg)&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（4）Touch.force</strong></p><p><code>Touch.force</code>属性返回一个<code>0</code>到<code>1</code>之间的数值，表示触摸压力。<code>0</code>代表没有压力，<code>1</code>代表硬件所能识别的最大压力。</p><p><strong>（5）Touch.target</strong></p><p><code>Touch.target</code>属性返回一个元素节点，代表触摸发生时所在的那个元素节点。即使触摸点已经离开了这个节点，该属性依然不变。</p><h1 id="TouchList-接口"><a href="#TouchList-接口" class="headerlink" title="TouchList 接口"></a>TouchList 接口</h1><p><code>TouchList</code>接口表示一组触摸点的集合。它的实例是一个类似数组的对象，成员是<code>Touch</code>的实例对象，表示所有触摸点。用户用三根手指触摸，产生的<code>TouchList</code>实例就会包含三个成员，每根手指的触摸点对应一个<code>Touch</code>实例对象。</p><p>它的实例主要通过触摸事件的<code>TouchEvent.touches</code>、<code>TouchEvent.changedTouches</code>、<code>TouchEvent.targetTouches</code>这几个属性获取。</p><p>它的实例属性和实例方法只有两个。</p><ul><li><code>TouchList.length</code>：数值，表示成员数量（即触摸点的数量）。</li><li><code>TouchList.item()</code>：返回指定位置的成员，它的参数是该成员的位置编号（从零开始）。</li></ul><h1 id="TouchEvent-接口"><a href="#TouchEvent-接口" class="headerlink" title="TouchEvent 接口"></a>TouchEvent 接口</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>TouchEvent 接口继承了 Event 接口，表示由触摸引发的事件实例，通常来自触摸屏或轨迹板。除了被继承的属性以外，它还有一些自己的属性。</p><p>浏览器原生提供<code>TouchEvent()</code>构造函数，用来生成触摸事件的实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> TouchEvent(type, options);</span><br></pre></td></tr></table></figure><p><code>TouchEvent()</code>构造函数可以接受两个参数，第一个参数是字符串，表示事件类型；第二个参数是事件的配置对象，该参数是可选的，对象的所有属性也是可选的。除了<code>Event</code>接口的配置属性，该接口还有一些自己的配置属性。</p><ul><li><code>touches</code>：<code>TouchList</code>实例，代表所有的当前处于活跃状态的触摸点，默认值是一个空数组<code>[]</code>。</li><li><code>targetTouches</code>：<code>TouchList</code>实例，代表所有处在触摸的目标元素节点内部、且仍然处于活动状态的触摸点，默认值是一个空数组<code>[]</code>。</li><li><code>changedTouches</code>：<code>TouchList</code>实例，代表本次触摸事件的相关触摸点，默认值是一个空数组<code>[]</code>。</li><li><code>ctrlKey</code>：布尔值，表示 Ctrl 键是否同时按下，默认值为<code>false</code>。</li><li><code>shiftKey</code>：布尔值，表示 Shift 键是否同时按下，默认值为<code>false</code>。</li><li><code>altKey</code>：布尔值，表示 Alt 键是否同时按下，默认值为<code>false</code>。</li><li><code>metaKey</code>：布尔值，表示 Meta 键（或 Windows 键）是否同时按下，默认值为<code>false</code>。</li></ul><h2 id="实例属性-1"><a href="#实例属性-1" class="headerlink" title="实例属性"></a>实例属性</h2><p>TouchEvent 接口的实例具有<code>Event</code>实例的所有属性和方法，此外还有一些它自己的实例属性，这些属性全部都是只读。</p><p><strong>（1）TouchEvent.altKey，TouchEvent.ctrlKey，TouchEvent.shiftKey，TouchEvent.metaKey</strong></p><ul><li><code>TouchEvent.altKey</code>：布尔值，表示触摸时是否按下了 Alt 键。</li><li><code>TouchEvent.ctrlKey</code>：布尔值，表示触摸时是否按下了 Ctrl 键。</li><li><code>TouchEvent.shiftKey</code>：布尔值：表示触摸时是否按下了 Shift 键。</li><li><code>TouchEvent.metaKey</code>：布尔值，表示触摸时是否按下了 Meta 键（或 Windows 键）。</li></ul><p>下面是一个示例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">someElement.addEventListener(</span><br><span class="line">  <span class="string">&quot;touchstart&quot;</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;altKey = &quot;</span> + e.altKey);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;ctrlKey = &quot;</span> + e.ctrlKey);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;metaKey = &quot;</span> + e.metaKey);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;shiftKey = &quot;</span> + e.shiftKey);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>（2）TouchEvent.changedTouches</strong></p><p><code>TouchEvent.changedTouches</code>属性返回一个<code>TouchList</code>实例，成员是一组<code>Touch</code>实例对象，表示本次触摸事件的相关触摸点。</p><p>对于不同的时间，该属性的含义有所不同。</p><ul><li><code>touchstart</code>事件：被激活的触摸点</li><li><code>touchmove</code>事件：发生变化的触摸点</li><li><code>touchend</code>事件：消失的触摸点（即不再被触碰的点）</li></ul><p>下面是一个示例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">someElement.addEventListener(</span><br><span class="line">  <span class="string">&quot;touchmove&quot;</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; e.changedTouches.length; i++) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(e.changedTouches[i].identifier);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>（3）TouchEvent.touches</strong></p><p><code>TouchEvent.touches</code>属性返回一个<code>TouchList</code>实例，成员是所有仍然处于活动状态（即触摸中）的触摸点。一般来说，一个手指就是一个触摸点。</p><p>下面是一个示例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">someElement.addEventListener(</span><br><span class="line">  <span class="string">&quot;touchstart&quot;</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (e.touches.length) &#123;</span><br><span class="line">      <span class="comment">// 一根手指触摸</span></span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        handle_one_touch(e);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="comment">// 两根手指触摸</span></span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        handle_two_touches(e);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="comment">// 三根手指触摸</span></span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        handle_three_touches(e);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="comment">// 其他情况</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Not supported&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>（4）TouchEvent.targetTouches</strong></p><p><code>TouchEvent.targetTouches</code>属性返回一个<code>TouchList</code>实例，成员是触摸事件的目标元素节点内部、所有仍然处于活动状态（即触摸中）的触摸点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">touches_in_target</span>(<span class="params">ev</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ev.touches.length === ev.targetTouches.length ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码用来判断，是否所有触摸点都在目标元素内。</p><h1 id="触摸事件的种类"><a href="#触摸事件的种类" class="headerlink" title="触摸事件的种类"></a>触摸事件的种类</h1><p>触摸引发的事件，有以下几种。可以通过<code>TouchEvent.type</code>属性，查看到底发生的是哪一种事件。</p><ul><li><code>touchstart</code>：用户开始触摸时触发，它的<code>target</code>属性返回发生触摸的元素节点。</li><li><code>touchend</code>：用户不再接触触摸屏时（或者移出屏幕边缘时）触发，它的<code>target</code>属性与<code>touchstart</code>事件一致的，就是开始触摸时所在的元素节点。它的<code>changedTouches</code>属性返回一个<code>TouchList</code>实例，包含所有不再触摸的触摸点（即<code>Touch</code>实例对象）。</li><li><code>touchmove</code>：用户移动触摸点时触发，它的<code>target</code>属性与<code>touchstart</code>事件一致。如果触摸的半径、角度、力度发生变化，也会触发该事件。</li><li><code>touchcancel</code>：触摸点取消时触发，比如在触摸区域跳出一个情态窗口（modal window）、触摸点离开了文档区域（进入浏览器菜单栏）、用户的触摸点太多，超过了支持的上限（自动取消早先的触摸点）。</li></ul><p>下面是一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> el = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;canvas&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">el.addEventListener(<span class="string">&quot;touchstart&quot;</span>, handleStart, <span class="literal">false</span>);</span><br><span class="line">el.addEventListener(<span class="string">&quot;touchmove&quot;</span>, handleMove, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleStart</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  evt.preventDefault();</span><br><span class="line">  <span class="keyword">var</span> touches = evt.changedTouches;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; touches.length; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(touches[i].pageX, touches[i].pageY);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleMove</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  evt.preventDefault();</span><br><span class="line">  <span class="keyword">var</span> touches = evt.changedTouches;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; touches.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> touch = touches[i];</span><br><span class="line">    <span class="built_in">console</span>.log(touch.pageX, touch.pageY);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="表单事件的种类"><a href="#表单事件的种类" class="headerlink" title="表单事件的种类"></a>表单事件的种类</h1><h2 id="input-事件"><a href="#input-事件" class="headerlink" title="input 事件"></a>input 事件</h2><p><code>input</code>事件当<code>&lt;input&gt;</code>、<code>&lt;select&gt;</code>、<code>&lt;textarea&gt;</code>的值发生变化时触发。对于复选框（<code>&lt;input type=checkbox&gt;</code>）或单选框（<code>&lt;input type=radio&gt;</code>），用户改变选项时，也会触发这个事件。另外，对于打开<code>contenteditable</code>属性的元素，只要值发生变化，也会触发<code>input</code>事件。</p><p><code>input</code>事件的一个特点，就是会连续触发，比如用户每按下一次按键，就会触发一次<code>input</code>事件。</p><p><code>input</code>事件对象继承了<code>InputEvent</code>接口。</p><h2 id="select-事件"><a href="#select-事件" class="headerlink" title="select 事件"></a>select 事件</h2><p><code>select</code>事件当在<code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code>里面选中文本时触发。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;input id=&quot;test&quot; type=&quot;text&quot; value=&quot;Select me!&quot; /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> elem = <span class="built_in">document</span>.getElementById(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">elem.addEventListener(</span><br><span class="line">  <span class="string">&quot;select&quot;</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.type); <span class="comment">// &quot;select&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>选中的文本可以通过<code>event.target</code>元素的<code>selectionDirection</code>、<code>selectionEnd</code>、<code>selectionStart</code>和<code>value</code>属性拿到。</p><h2 id="Change-事件"><a href="#Change-事件" class="headerlink" title="Change 事件"></a>Change 事件</h2><p><code>Change</code>事件当<code>&lt;input&gt;</code>、<code>&lt;select&gt;</code>、<code>&lt;textarea&gt;</code>的值发生变化时触发。它与<code>input</code>事件的最大不同，就是不会连续触发，只有当全部修改完成时才会触发，另一方面<code>input</code>事件必然伴随<code>change</code>事件。具体来说，分成以下几种情况。</p><ul><li>激活单选框（radio）或复选框（checkbox）时触发。</li><li>用户提交时触发。比如，从下列列表（select）完成选择，在日期或文件输入框完成选择。</li><li>当文本框或<code>&lt;textarea&gt;</code>元素的值发生改变，并且丧失焦点时触发。</li></ul><p>下面是一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;select size=&quot;1&quot; onchange=&quot;changeEventHandler(event);&quot;&gt;</span></span><br><span class="line"><span class="comment">//   &lt;option&gt;chocolate&lt;/option&gt;</span></span><br><span class="line"><span class="comment">//   &lt;option&gt;strawberry&lt;/option&gt;</span></span><br><span class="line"><span class="comment">//   &lt;option&gt;vanilla&lt;/option&gt;</span></span><br><span class="line"><span class="comment">// &lt;/select&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeEventHandler</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(event.target.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="invalid-事件"><a href="#invalid-事件" class="headerlink" title="invalid 事件"></a>invalid 事件</h2><p>用户提交表单时，如果表单元素的值不满足校验条件，就会触发<code>invalid</code>事件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">required</span> <span class="attr">oninvalid</span>=<span class="string">&quot;console.log(&#x27;invalid input&#x27;)&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面代码中，输入框是必填的。如果不填，用户点击按钮提交时，就会触发输入框的<code>invalid</code>事件，导致提交被取消。</p><h2 id="reset-事件，submit-事件"><a href="#reset-事件，submit-事件" class="headerlink" title="reset 事件，submit 事件"></a>reset 事件，submit 事件</h2><p>这两个事件发生在表单对象<code>&lt;form&gt;</code>上，而不是发生在表单的成员上。</p><p><code>reset</code>事件当表单重置（所有表单成员变回默认值）时触发。</p><p><code>submit</code>事件当表单数据向服务器提交时触发。注意，<code>submit</code>事件的发生对象是<code>&lt;form&gt;</code>元素，而不是<code>&lt;button&gt;</code>元素，因为提交的是表单，而不是按钮。</p><h1 id="资源事件"><a href="#资源事件" class="headerlink" title="资源事件"></a>资源事件</h1><h2 id="beforeunload-事件"><a href="#beforeunload-事件" class="headerlink" title="beforeunload 事件"></a>beforeunload 事件</h2><p><code>beforeunload</code>事件在窗口、文档、各种资源将要卸载前触发。它可以用来防止用户不小心卸载资源。</p><p>如果该事件对象的<code>returnValue</code>属性是一个非空字符串，那么浏览器就会弹出一个对话框，询问用户是否要卸载该资源。但是，用户指定的字符串可能无法显示，浏览器会展示预定义的字符串。如果用户点击“取消”按钮，资源就不会卸载。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;beforeunload&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.returnValue = <span class="string">&quot;你确定离开吗？&quot;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，用户如果关闭窗口，浏览器会弹出一个窗口，要求用户确认。</p><p>浏览器对这个事件的行为很不一致，有的浏览器调用<code>event.preventDefault()</code>，也会弹出对话框。IE 浏览器需要显式返回一个非空的字符串，才会弹出对话框。而且，大多数浏览器在对话框中不显示指定文本，只显示默认文本。因此，可以采用下面的写法，取得最大的兼容性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;beforeunload&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> confirmationMessage = <span class="string">&quot;确认关闭窗口？&quot;</span>;</span><br><span class="line"></span><br><span class="line">  e.returnValue = confirmationMessage;</span><br><span class="line">  <span class="keyword">return</span> confirmationMessage;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意，许多手机浏览器默认忽略这个事件，桌面浏览器也有方法忽略这个事件。所以，它可能根本不会生效，不能依赖它来阻止用户关闭窗口。</p><h2 id="unload-事件"><a href="#unload-事件" class="headerlink" title="unload 事件"></a>unload 事件</h2><p><code>unload</code>事件在窗口关闭或者<code>document</code>对象将要卸载时触发。它的触发顺序排在<code>beforeunload</code>、<code>pagehide</code>事件后面。<code>unload</code>事件只在页面没有被浏览器缓存时才会触发，换言之，如果通过按下“前进/后退”导致页面卸载，并不会触发<code>unload</code>事件。</p><p><code>unload</code>事件发生时，文档处于一个特殊状态。所有资源依然存在，但是对用户来说都不可见，UI 互动全部无效。这个事件是无法取消的，即使在监听函数里面抛出错误，也不能停止文档的卸载。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;unload&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;文档将要卸载&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="load-事件"><a href="#load-事件" class="headerlink" title="load 事件"></a>load 事件</h2><p><code>load</code>事件在页面或某个资源加载成功时触发。注意，页面或资源从浏览器缓存加载，并不会触发<code>load</code>事件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;load&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;所有资源都加载完成&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>error</code>事件是在页面或资源加载失败时触发。<code>abort</code>事件在用户取消加载时触发。</p><p>这三个事件实际上属于进度事件，不仅发生在<code>document</code>对象，还发生在各种外部资源上面。浏览网页就是一个加载各种资源的过程，图像（image）、样式表（style sheet）、脚本（script）、视频（video）、音频（audio）、Ajax 请求（XMLHttpRequest）等等。这些资源和<code>document</code>对象、<code>window</code>对象、XMLHttpRequestUpload 对象，都会触发<code>load</code>事件和<code>error</code>事件。</p><h1 id="session-历史事件"><a href="#session-历史事件" class="headerlink" title="session 历史事件"></a>session 历史事件</h1><h2 id="pageshow-事件，pagehide-事件"><a href="#pageshow-事件，pagehide-事件" class="headerlink" title="pageshow 事件，pagehide 事件"></a>pageshow 事件，pagehide 事件</h2><p>默认情况下，浏览器会在当前会话（session）缓存页面，当用户点击“前进/后退”按钮时，浏览器就会从缓存中加载页面。</p><p>pageshow 事件在页面加载时触发，包括第一次加载和从缓存加载两种情况。如果要指定页面每次加载（不管是不是从浏览器缓存）时都运行的代码，可以放在这个事件的监听函数。</p><p>第一次加载时，它的触发顺序排在<code>load</code>事件后面。从缓存加载时，<code>load</code>事件不会触发，因为网页在缓存中的样子通常是<code>load</code>事件的监听函数运行后的样子，所以不必重复执行。同理，如果是从缓存中加载页面，网页内初始化的 JavaScript 脚本（比如 DOMContentLoaded 事件的监听函数）也不会执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;pageshow&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;pageshow: &quot;</span>, event);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>pageshow 事件有一个<code>persisted</code>属性，返回一个布尔值。页面第一次加载时，这个属性是<code>false</code>；当页面从缓存加载时，这个属性是<code>true</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;pageshow&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (event.persisted) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>pagehide</code>事件与<code>pageshow</code>事件类似，当用户通过“前进/后退”按钮，离开当前页面时触发。它与 unload 事件的区别在于，如果在 window 对象上定义<code>unload</code>事件的监听函数之后，页面不会保存在缓存中，而使用<code>pagehide</code>事件，页面会保存在缓存中。</p><p><code>pagehide</code>事件实例也有一个<code>persisted</code>属性，将这个属性设为<code>true</code>，就表示页面要保存在缓存中；设为<code>false</code>，表示网页不保存在缓存中，这时如果设置了 unload 事件的监听函数，该函数将在 pagehide 事件后立即运行。</p><p>如果页面包含<code>&lt;frame&gt;</code>或<code>&lt;iframe&gt;</code>元素，则<code>&lt;frame&gt;</code>页面的<code>pageshow</code>事件和<code>pagehide</code>事件，都会在主页面之前触发。</p><h2 id="popstate-事件"><a href="#popstate-事件" class="headerlink" title="popstate 事件"></a>popstate 事件</h2><p><code>popstate</code>事件在浏览器的<code>history</code>对象的当前记录发生显式切换时触发。注意，调用<code>history.pushState()</code>或<code>history.replaceState()</code>，并不会触发<code>popstate</code>事件。该事件只在用户在<code>history</code>记录之间显式切换时触发，比如鼠标点击“后退/前进”按钮，或者在脚本中调用<code>history.back()</code>、<code>history.forward()</code>、<code>history.go()</code>时触发。</p><p>该事件对象有一个<code>state</code>属性，保存<code>history.pushState</code>方法和<code>history.replaceState</code>方法为当前记录添加的<code>state</code>对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onpopstate = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;state: &quot;</span> + event.state);</span><br><span class="line">&#125;;</span><br><span class="line">history.pushState(&#123; <span class="attr">page</span>: <span class="number">1</span> &#125;, <span class="string">&quot;title 1&quot;</span>, <span class="string">&quot;?page=1&quot;</span>);</span><br><span class="line">history.pushState(&#123; <span class="attr">page</span>: <span class="number">2</span> &#125;, <span class="string">&quot;title 2&quot;</span>, <span class="string">&quot;?page=2&quot;</span>);</span><br><span class="line">history.replaceState(&#123; <span class="attr">page</span>: <span class="number">3</span> &#125;, <span class="string">&quot;title 3&quot;</span>, <span class="string">&quot;?page=3&quot;</span>);</span><br><span class="line">history.back(); <span class="comment">// state: &#123;&quot;page&quot;:1&#125;</span></span><br><span class="line">history.back(); <span class="comment">// state: null</span></span><br><span class="line">history.go(<span class="number">2</span>); <span class="comment">// state: &#123;&quot;page&quot;:3&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>pushState</code>方法向<code>history</code>添加了两条记录，然后<code>replaceState</code>方法替换掉当前记录。因此，连续两次<code>back</code>方法，会让当前条目退回到原始网址，它没有附带<code>state</code>对象，所以事件的<code>state</code>属性为<code>null</code>，然后前进两条记录，又回到<code>replaceState</code>方法添加的记录。</p><p>浏览器对于页面首次加载，是否触发<code>popstate</code>事件，处理不一样，Firefox 不触发该事件。</p><h2 id="hashchange-事件"><a href="#hashchange-事件" class="headerlink" title="hashchange 事件"></a>hashchange 事件</h2><p><code>hashchange</code>事件在 URL 的 hash 部分（即<code>#</code>号后面的部分，包括<code>#</code>号）发生变化时触发。该事件一般在<code>window</code>对象上监听。</p><p><code>hashchange</code>的事件实例具有两个特有属性：<code>oldURL</code>属性和<code>newURL</code>属性，分别表示变化前后的完整 URL。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// URL 是 http://www.example.com/</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;hashchange&quot;</span>, myFunction);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.oldURL);</span><br><span class="line">  <span class="built_in">console</span>.log(e.newURL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location.hash = <span class="string">&quot;part2&quot;</span>;</span><br><span class="line"><span class="comment">// http://www.example.com/</span></span><br><span class="line"><span class="comment">// http://www.example.com/#part2</span></span><br></pre></td></tr></table></figure><h1 id="网页状态事件"><a href="#网页状态事件" class="headerlink" title="网页状态事件"></a>网页状态事件</h1><h2 id="DOMContentLoaded-事件"><a href="#DOMContentLoaded-事件" class="headerlink" title="DOMContentLoaded 事件"></a>DOMContentLoaded 事件</h2><p>网页下载并解析完成以后，浏览器就会在<code>document</code>对象上触发 DOMContentLoaded 事件。这时，仅仅完成了网页的解析（整张页面的 DOM 生成了），所有外部资源（样式表、脚本、iframe 等等）可能还没有下载结束。也就是说，这个事件比<code>load</code>事件，发生时间早得多。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&quot;DOMContentLoaded&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;DOM生成&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意，网页的 JavaScript 脚本是同步执行的，脚本一旦发生堵塞，将推迟触发<code>DOMContentLoaded</code>事件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&quot;DOMContentLoaded&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;DOM 生成&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这段代码会推迟触发 DOMContentLoaded 事件</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000000</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="readystatechange-事件"><a href="#readystatechange-事件" class="headerlink" title="readystatechange 事件"></a>readystatechange 事件</h2><p><code>readystatechange</code>事件当 Document 对象和 XMLHttpRequest 对象的<code>readyState</code>属性发生变化时触发。<code>document.readyState</code>有三个可能的值：<code>loading</code>（网页正在加载）、<code>interactive</code>（网页已经解析完成，但是外部资源仍然处在加载状态）和<code>complete</code>（网页和所有外部资源已经结束加载，<code>load</code>事件即将触发）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">document</span>.readyState === <span class="string">&quot;interactive&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个事件可以看作<code>DOMContentLoaded</code>事件的另一种实现方法。</p><h1 id="窗口事件"><a href="#窗口事件" class="headerlink" title="窗口事件"></a>窗口事件</h1><h2 id="scroll-事件"><a href="#scroll-事件" class="headerlink" title="scroll 事件"></a>scroll 事件</h2><p><code>scroll</code>事件在文档或文档元素滚动时触发，主要出现在用户拖动滚动条。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;scroll&quot;</span>, callback);</span><br></pre></td></tr></table></figure><p>该事件会连续地大量触发，所以它的监听函数之中不应该有非常耗费计算的操作。推荐的做法是使用<code>requestAnimationFrame</code>或<code>setTimeout</code>控制该事件的触发频率，然后可以结合<code>customEvent</code>抛出一个新事件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> throttle = <span class="function"><span class="keyword">function</span> (<span class="params">type, name, obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = obj || <span class="built_in">window</span>;</span><br><span class="line">    <span class="keyword">var</span> running = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (running) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      running = <span class="literal">true</span>;</span><br><span class="line">      requestAnimationFrame(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        obj.dispatchEvent(<span class="keyword">new</span> CustomEvent(name));</span><br><span class="line">        running = <span class="literal">false</span>;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    obj.addEventListener(type, func);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 scroll 事件重定义为 optimizedScroll 事件</span></span><br><span class="line">  throttle(<span class="string">&quot;scroll&quot;</span>, <span class="string">&quot;optimizedScroll&quot;</span>);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;optimizedScroll&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Resource conscious scroll callback!&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>throttle</code>函数用于控制事件触发频率，<code>requestAnimationFrame</code>方法保证每次页面重绘（每秒 60 次），只会触发一次<code>scroll</code>事件的监听函数。也就是说，上面方法将<code>scroll</code>事件的触发频率，限制在每秒 60 次。具体来说，就是<code>scroll</code>事件只要频率低于每秒 60 次，就会触发<code>optimizedScroll</code>事件，从而执行<code>optimizedScroll</code>事件的监听函数。</p><p>改用<code>setTimeout</code>方法，可以放置更大的时间间隔。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">&quot;scroll&quot;</span>, scrollThrottler, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> scrollTimeout;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">scrollThrottler</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!scrollTimeout) &#123;</span><br><span class="line">      scrollTimeout = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        scrollTimeout = <span class="literal">null</span>;</span><br><span class="line">        actualScrollHandler();</span><br><span class="line">      &#125;, <span class="number">66</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">actualScrollHandler</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>上面代码中，每次<code>scroll</code>事件都会执行<code>scrollThrottler</code>函数。该函数里面有一个定时器<code>setTimeout</code>，每 66 毫秒触发一次（每秒 15 次）真正执行的任务<code>actualScrollHandler</code>。</p><p>下面是一个更一般的<code>throttle</code>函数的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> time = <span class="built_in">Date</span>.now();</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (time + wait - <span class="built_in">Date</span>.now() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      fn();</span><br><span class="line">      time = <span class="built_in">Date</span>.now();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;scroll&quot;</span>, throttle(callback, <span class="number">1000</span>));</span><br></pre></td></tr></table></figure><p>上面的代码将<code>scroll</code>事件的触发频率，限制在一秒一次。</p><p><code>lodash</code>函数库提供了现成的<code>throttle</code>函数，可以直接使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;scroll&quot;</span>, _.throttle(callback, <span class="number">1000</span>));</span><br></pre></td></tr></table></figure><h2 id="resize-事件"><a href="#resize-事件" class="headerlink" title="resize 事件"></a>resize 事件</h2><p><code>resize</code>事件在改变浏览器窗口大小时触发，主要发生在<code>window</code>对象上面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> resizeMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">document</span>.body.clientWidth &lt; <span class="number">768</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;移动设备的视口&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;resize&quot;</span>, resizeMethod, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>该事件也会连续地大量触发，所以最好像上面的<code>scroll</code>事件一样，通过<code>throttle</code>函数控制事件触发频率。</p><h2 id="fullscreenchange-事件，fullscreenerror-事件"><a href="#fullscreenchange-事件，fullscreenerror-事件" class="headerlink" title="fullscreenchange 事件，fullscreenerror 事件"></a>fullscreenchange 事件，fullscreenerror 事件</h2><p><code>fullscreenchange</code>事件在进入或推出全屏状态时触发，该事件发生在<code>document</code>对象上面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&quot;fullscreenchange&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">document</span>.fullscreenElement);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>fullscreenerror</code>事件在浏览器无法切换到全屏状态时触发。</p><h1 id="剪贴板事件"><a href="#剪贴板事件" class="headerlink" title="剪贴板事件"></a>剪贴板事件</h1><p>以下三个事件属于剪贴板操作的相关事件。</p><ul><li><code>cut</code>：将选中的内容从文档中移除，加入剪贴板时触发。</li><li><code>copy</code>：进行复制动作时触发。</li><li><code>paste</code>：剪贴板内容粘贴到文档后触发。</li></ul><p>这三个事件都是<code>ClipboardEvent</code>接口的实例。<code>ClipboardEvent</code>有一个实例属性<code>clipboardData</code>，是一个 DataTransfer 对象，存放剪贴的数据。具体的 API 接口和操作方法，请参见《触摸事件》的 DataTransfer 对象部分。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&quot;copy&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  e.clipboardData.setData(<span class="string">&quot;text/plain&quot;</span>, <span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">  e.clipboardData.setData(<span class="string">&quot;text/html&quot;</span>, <span class="string">&quot;&lt;b&gt;Hello, world!&lt;/b&gt;&quot;</span>);</span><br><span class="line">  e.preventDefault();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的代码使得复制进入剪贴板的，都是开发者指定的数据，而不是用户想要拷贝的数据。</p><h1 id="焦点事件"><a href="#焦点事件" class="headerlink" title="焦点事件"></a>焦点事件</h1><p>焦点事件发生在元素节点和<code>document</code>对象上面，与获得或失去焦点相关。它主要包括以下四个事件。</p><ul><li><code>focus</code>：元素节点获得焦点后触发，该事件不会冒泡。</li><li><code>blur</code>：元素节点失去焦点后触发，该事件不会冒泡。</li><li><code>focusin</code>：元素节点将要获得焦点时触发，发生在<code>focus</code>事件之前。该事件会冒泡。</li><li><code>focusout</code>：元素节点将要失去焦点时触发，发生在<code>blur</code>事件之前。该事件会冒泡。</li></ul><p>这四个事件都继承了<code>FocusEvent</code>接口。<code>FocusEvent</code>实例具有以下属性。</p><ul><li><code>FocusEvent.target</code>：事件的目标节点。</li><li><code>FocusEvent.relatedTarget</code>：对于<code>focusin</code>事件，返回失去焦点的节点；对于<code>focusout</code>事件，返回将要接受焦点的节点；对于<code>focus</code>和<code>blur</code>事件，返回<code>null</code>。</li></ul><p>由于<code>focus</code>和<code>blur</code>事件不会冒泡，只能在捕获阶段触发，所以<code>addEventListener</code>方法的第三个参数需要设为<code>true</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">form.addEventListener(</span><br><span class="line">  <span class="string">&quot;focus&quot;</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    event.target.style.background = <span class="string">&quot;pink&quot;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">true</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">form.addEventListener(</span><br><span class="line">  <span class="string">&quot;blur&quot;</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    event.target.style.background = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">true</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上面代码针对表单的文本输入框，接受焦点时设置背景色，失去焦点时去除背景色。</p></div><footer class="post-footer"><div class="reward-container"><div></div><button onclick='document.querySelector(".post-reward").classList.toggle("active")'>赞赏</button><div class="post-reward"><div><img src="/images/wechat.jpg" alt="任毅 微信"> <span>微信</span></div><div><img src="/images/alipay.jpg" alt="任毅 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"><strong>本文作者： </strong>任毅</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://obsidianstar.cn/2021/01/14/dom/event-type/" title="事件种类">https://obsidianstar.cn/2021/01/14/dom/event-type/</a></li></ul></div><div class="post-tags"><a href="/tags/dom/" rel="tag"><i class="fa fa-tag"></i> dom</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2021/01/14/dom/event/" rel="prev" title="事件模型"><i class="fa fa-chevron-left"></i> 事件模型</a></div><div class="post-nav-item"><a href="/2021/01/14/dom/element/" rel="next" title="Element对象">Element对象 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">任毅</span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动</div></div></footer><script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.4.0/pjax.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script>var pjax = new Pjax({
  selectors: [
    'head title',
    '.page-configurations',
    '.main-inner',
    '.post-toc-wrap',
    '.languages',
    '.pjax'
  ],
  analytics: false,
  cacheBust: false,
  scrollRestoration: false,
  scrollTo: !CONFIG.bookmark.enable
});

document.addEventListener('pjax:success', () => {
  pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  const hasTOC = document.querySelector('.post-toc');
  document.querySelector('.sidebar-inner').classList.toggle('sidebar-nav-active', hasTOC);
  document.querySelector(hasTOC ? '.sidebar-nav-toc' : '.sidebar-nav-overview').click();
  NexT.utils.updateSidebarPosition();
});</script><script src="/js/local-search.js"></script><script data-pjax>if (document.querySelectorAll('.pdf-container').length) {
  NexT.utils.getScript('https://cdn.jsdelivr.net/npm/pdfobject@2.2.5/pdfobject.min.js', () => {
    document.querySelectorAll('.pdf-container').forEach(element => {
      PDFObject.embed(element.dataset.target, element, {
        pdfOpenParams: {
          navpanes : 0,
          toolbar  : 0,
          statusbar: 0,
          pagemode : 'thumbs',
          view     : 'FitH'
        },
        PDFJS_URL: '/lib/pdf/web/viewer.html',
        height   : element.dataset.height
      });
    });
  }, window.PDFObject);
}</script><script data-pjax>var mermaidElements = document.querySelectorAll('.mermaid');
if (mermaidElements.length) {
  NexT.utils.getScript('https://cdn.jsdelivr.net/npm/mermaid@8.9.2/dist/mermaid.min.js', () => {
    mermaidElements.forEach(element => {
      const newElement = document.createElement('div');
      newElement.innerHTML = element.innerHTML;
      newElement.className = element.className;
      element.parentNode.replaceChild(newElement, element);
    });

    mermaid.init({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    }, '.mermaid');
  }, window.mermaid);
}</script><script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="pjax"></div></body></html>